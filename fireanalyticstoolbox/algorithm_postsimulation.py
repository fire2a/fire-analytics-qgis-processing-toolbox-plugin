# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FireToolbox
                                 A QGIS plugin
 A collection of fire insights related algorithms
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-08-30
        copyright            : (C) 2023 by Fernando Badilla Veliz - Fire2a.com
        email                : fbadilla@ing.uchile.cl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
TODO:
    group results https://gis.stackexchange.com/questions/416542/adding-output-layers-of-qgis-processing-scripts-to-group-using-pyqgis
util:
    https://gis.stackexchange.com/questions/314036/programmatically-styling-layer-after-output-is-returned-from-qgis-3-processing-s
    https://lists.osgeo.org/pipermail/qgis-developer/2021-June/063741.html
    https://gis.stackexchange.com/questions/375987/customizing-qgsprocessing-output-layer-name
    https://gis.stackexchange.com/questions/448603/change-the-symbology-of-a-vector-output-layer-that-is-returned-from-a-processing
    https://gis.stackexchange.com/questions/414559/qgis-iterative-rasterize-naming
    https://gis.stackexchange.com/questions/306659/pyqgis-style-layer-after-processing-with-qml-file

"""

__author__ = "Fernando Badilla Veliz - Fire2a.com"
__date__ = "2023-08-30"
__copyright__ = "(C) 2023 by Fernando Badilla Veliz - Fire2a.com"

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = "$Format:%H$"

from functools import partial
from multiprocessing import Pool, cpu_count
from os import sep
from pathlib import Path
from pickle import dump as pickle_dump
from pickle import load as pickle_load
from platform import system as platform_system
from re import search
from typing import Any, Tuple

import processing
from fire2a.cell2fire import glob_numbered_files
from fire2a.raster import id2xy, read_raster, transform_coords_to_georef
from fire2a.utils import loadtxt_nodata
from networkx import DiGraph, MultiDiGraph, betweenness_centrality, single_source_dijkstra_path
from numpy import any as np_any
from numpy import array, float32, int16, int32, loadtxt, ndarray, sqrt, vectorize, vstack, zeros
from osgeo import gdal, osr
from osgeo.gdal import GDT_Float32, GDT_Int16
from qgis.core import (Qgis, QgsColorRampShader, QgsFeature, QgsFeatureSink, QgsField, QgsFields, QgsGeometry,
                       QgsGraduatedSymbolRenderer, QgsLineString, QgsMessageLog, QgsPalettedRasterRenderer, QgsPoint,
                       QgsProcessing, QgsProcessingAlgorithm, QgsProcessingContext, QgsProcessingException,
                       QgsProcessingLayerPostProcessorInterface, QgsProcessingParameterBoolean,
                       QgsProcessingParameterDefinition, QgsProcessingParameterEnum, QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterFile, QgsProcessingParameterFileDestination,
                       QgsProcessingParameterFolderDestination, QgsProcessingParameterNumber,
                       QgsProcessingParameterRasterDestination, QgsProcessingParameterRasterLayer, QgsProcessingUtils,
                       QgsProject, QgsRasterBandStats, QgsRasterFileWriter, QgsRasterShader,
                       QgsSingleBandPseudoColorRenderer, QgsWkbTypes)
from qgis.PyQt.QtCore import QCoreApplication, QVariant
from qgis.PyQt.QtGui import QColor, QIcon
from scipy import stats as scipy_stats

from .algorithm_utils import get_output_raster_format, write_log
from .config import NAME, SIM_OUTPUTS, STATS, TAG, jolo

# from matplotlib import colormaps
# from matplotlib.colors import to_rgba_array


plugin_dir = Path(__file__).parent
assets_dir = Path(plugin_dir, "simulator")
gdal.UseExceptions()


class IgnitionPointsSIMPP(QgsProcessingAlgorithm):
    """Ignition Points Simulation Post Processing Algorithm load LogFile.txt and create a point layer"""

    BASE_LAYER = "BaseLayer"
    IN_LOG = "LogFile"
    OUT_LAYER = "IgnitionPointsLayer"

    def checkParameterValues(self, parameters: dict[str, Any], context: QgsProcessingContext) -> tuple[bool, str]:
        """log file exists and is not empty"""
        log_file = Path(self.parameterAsString(parameters, self.IN_LOG, context))
        if not log_file.stat().st_size > 0:
            return False, f"{log_file} file is empty!"
        ip_log = loadtxt(log_file, delimiter=",", skiprows=1, dtype=[("sim", int32), ("cellid", int32)])
        if len(ip_log) == 0:
            return False, f"{log_file} file contains only headers but no ignition points"
        return True, ""

    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                name=self.BASE_LAYER,
                description=self.tr("Base raster (normally fuel or elevation) to get the geotransform"),
                defaultValue=[QgsProcessing.TypeRaster],
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterFile(
                name=self.IN_LOG,
                description="Simulator log file (normally firesim_yymmdd_HHMMSS/results/IgnitionsHistory/ignitions_log.csv)",
                behavior=QgsProcessingParameterFile.File,
                extension="csv",
                defaultValue=None,
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                name=self.OUT_LAYER,
                description=self.tr("Output ignition point(s) layer"),
                type=QgsProcessing.TypeVectorPoint,
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """Here is where the processing itself takes place."""
        # BASE LAYER
        base_raster = self.parameterAsRasterLayer(parameters, self.BASE_LAYER, context)
        _, raster_props = read_raster(base_raster.publicSource(), data=False)
        feedback.pushDebugInfo(f"base_raster.crs.authid: {base_raster.crs().authid()}\n")
        # ignition points csv log file
        log_csv = Path(self.parameterAsString(parameters, self.IN_LOG, context))
        feedback.pushDebugInfo(f"reading {log_csv=}")
        ip_log = loadtxt(log_csv, delimiter=",", skiprows=1, dtype=[("sim", int32), ("cellid", int32)])
        # create layer
        # fields
        fields = QgsFields()
        fields.append(QgsField(name="simulation", type=QVariant.Int, len=10))
        fields.append(QgsField(name="cell", type=QVariant.Int, len=10))
        fields.append(QgsField(name="x_pixel", type=QVariant.Int, len=10))
        fields.append(QgsField(name="y_line", type=QVariant.Int, len=10))
        # sink
        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUT_LAYER,
            context,
            fields,
            QgsWkbTypes.Point,  # >v3.3 ? Qgis.WkbType.Point
            base_raster.crs(),
        )
        simulation_id, ignition_cell = ip_log["sim"], ip_log["cellid"]
        ignition_cell -= 1  # 1 based to 0 based
        # add features
        for sim_id, cell in zip(simulation_id, ignition_cell):
            i, j = id2xy(cell, raster_props["RasterXSize"], raster_props["RasterYSize"])
            x, y = transform_coords_to_georef(i + 0.5, j + 0.5, raster_props["Transform"])
            feature = QgsFeature(fields)
            feature.setId(int(sim_id))
            feature.setAttributes([int(sim_id), int(cell + 1), int(i), int(j)])
            feature.setGeometry(QgsGeometry(QgsPoint(x, y)))
            sink.addFeature(feature, QgsFeatureSink.FastInsert)
            feedback.pushDebugInfo(f"simulation id: {sim_id}, ignition cell: {cell}, x: {x}, y: {y}, i: {i}, j: {j}")
            if feedback.isCanceled():
                break
        processing.run(
            "qgis:setstyleforvectorlayer",
            {"INPUT": dest_id, "STYLE": str(Path(assets_dir, "ignition_points.qml"))},
            context=context,
            feedback=feedback,
            is_child_algorithm=True,
        )
        # layer = QgsProcessingUtils.mapLayerFromString(dest_id, context)
        layer_details = context.LayerDetails(
            "Ignition Points",  # always name it as Ignition Points, alternative: layer.name()
            context.project(),
            dest_id,
            QgsProcessingUtils.LayerHint.Vector,
        )
        layer_details.groupName = NAME["layer_group"]
        layer_details.layerSortKey = 0
        context.addLayerToLoadOnCompletion(dest_id, layer_details)

        write_log(feedback, name=self.name())
        return {self.OUT_LAYER: dest_id}

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return IgnitionPointsSIMPP()

    def group(self):
        return self.tr("Simulator Post Processing")

    def groupId(self):
        return "simulatorpostprocessing"

    def name(self):
        return "ignitionpoints"

    def displayName(self):
        return self.tr("Ignition Points")

    def icon(self):
        return QIcon(":/plugins/fireanalyticstoolbox/assets/ignitionpoint.svg")


class PostSimulationAlgorithm(QgsProcessingAlgorithm):
    """Cell2Fire results post processing bundle"""

    BASE_LAYER = "BaseLayer"
    OUTPUT_DIR = "OutputDirectory"
    RESULTS_DIR = "ResultsDirectory"
    MSGS = "EnablePropagationDiGraph"
    POLYSCARS = "EnablePropagationScars"

    def initAlgorithm(self, config):
        """inputs and output of the algorithm"""
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                name=self.BASE_LAYER,
                description=self.tr("Base raster (normally fuel or elevation) to get the geotransform"),
                defaultValue=[QgsProcessing.TypeRaster],
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterBoolean(
                name=self.MSGS,
                description=("Enable propagation directed graph"),
                defaultValue=False,
                optional=True,
            )
        )
        self.addParameter(
            QgsProcessingParameterBoolean(
                name=self.POLYSCARS,
                description=("Enable propagation scars polygons"),
                defaultValue=False,
                optional=True,
            )
        )
        project_path = QgsProject().instance().absolutePath()
        project_path = project_path if project_path != "" else None
        self.addParameter(
            QgsProcessingParameterFile(
                name=self.RESULTS_DIR,
                description="Simulation Results directory (normally firesim_yymmdd_HHMMSS/results)",
                behavior=QgsProcessingParameterFile.Folder,
                defaultValue=project_path,
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterFolderDestination(
                name=self.OUTPUT_DIR,
                description="Output directory",
                defaultValue=None,
                optional=True,
                createByDefault=True,
            )
        )

    def checkParameterValues(self, parameters: dict[str, Any], context: QgsProcessingContext) -> tuple[bool, str]:
        results_directory = Path(self.parameterAsString(parameters, self.RESULTS_DIR, context))
        if not results_directory.is_dir():
            return False, f"provided results is not a directory: {results_directory}"
        if next(results_directory.iterdir(), None) is None:
            return False, f"provided results is empty: {results_directory}"
        return True, ""

    def processAlgorithm(self, parameters, context, feedback):
        """Here is where the processing itself takes place."""
        # feedback.pushDebugInfo("processAlgorithm start")
        # feedback.pushDebugInfo(f"context args: {context.asQgisProcessArguments()}")
        # feedback.pushDebugInfo(f"parameters {parameters}")
        output_dict = {}
        # OUTPUT DIR
        output_dir = Path(self.parameterAsString(parameters, self.OUTPUT_DIR, context))
        out_is = output_dir.is_dir()
        feedback.pushDebugInfo(f"output_dir: {output_dir}, {output_dir.is_dir()}")
        output_dict[self.OUTPUT_DIR] = output_dir
        # BASE LAYER
        base_raster = self.parameterAsRasterLayer(parameters, self.BASE_LAYER, context)
        sp_ref = osr.SpatialReference()
        sp_ref.SetFromUserInput(base_raster.crs().authid())
        # RESULTS DIR
        results_dir = Path(self.parameterAsString(parameters, self.RESULTS_DIR, context))

        # IgnitionPoints
        # log_file = Path(results_dir, "LogFile.txt")
        log_file = Path(results_dir, "IgnitionsHistory", "ignitions_log.csv")
        if log_file.is_file() and log_file.stat().st_size > 0:
            feedback.pushDebugInfo(log_file.read_text())
            if out_is:
                out = (output_dir / "IgnitionPointsLayer").touch()
            else:
                out = QgsProcessing.TEMPORARY_OUTPUT
            igpt_out = processing.run(
                "fire2a:ignitionpoints",
                {
                    "BaseLayer": base_raster,
                    "IgnitionPointsLayer": out,
                    # "LogFile": str(results_dir / "LogFile.txt"),
                    "LogFile": str(log_file),
                },
                context=context,
                feedback=feedback,
                is_child_algorithm=True,
            )
            layer_details = QgsProcessingContext.LayerDetails(
                "Ignition Points",
                context.project(),
                "Ignition Points",
                QgsProcessingUtils.LayerHint.Vector,
            )
            layer_details.groupName = NAME["layer_group"]
            layer_details.layerSortKey = 0
            context.addLayerToLoadOnCompletion(
                igpt_out["IgnitionPointsLayer"],
                layer_details,
            )
            output_dict["IgnitionPoints"] = igpt_out["IgnitionPointsLayer"]
        else:
            feedback.reportError(f"{log_file} not found or empty!")
            raise QgsProcessingException(f"{log_file} not found or empty!")

        # stats
        for stat in STATS:
            if sample_file := next(Path(results_dir).glob(stat["dir"] + sep + stat["file"] + "*" + stat["ext"]), None):
                stat_out = processing.run(
                    "fire2a:statistic",
                    {
                        "BaseLayer": base_raster,
                        "SampleStatisticFile": str(sample_file),
                        "DataType": stat["dtype"],
                        "OutputRaster": QgsProcessing.TEMPORARY_OUTPUT,
                        "OutputRasterStats": QgsProcessing.TEMPORARY_OUTPUT,
                    },
                    context=context,
                    feedback=feedback,
                    is_child_algorithm=True,
                )
                # ui load
                # each sim in a band
                layer_details = context.LayerDetails(
                    stat["name"],
                    context.project(),
                    stat["name"],
                    QgsProcessingUtils.LayerHint.Raster,
                )
                layer_details.groupName = NAME["layer_group"]
                layer_details.layerSortKey = 5
                context.addLayerToLoadOnCompletion(stat_out["OutputRaster"], layer_details)
                if stat["dtype"] == "float32":
                    context.layerToLoadOnCompletionDetails(stat_out["OutputRaster"]).setPostProcessor(
                        run_alg_styler(
                            stat["name"],
                        )
                    )
                else:
                    context.layerToLoadOnCompletionDetails(stat_out["OutputRaster"]).setPostProcessor(
                        run_alg_styler_bin(
                            stat["name"],
                        )
                    )
                output_dict[stat["name"]] = stat_out["OutputRaster"]
                # mean & stddev
                layer_details = context.LayerDetails(
                    "Mean&StdDev " + stat["name"],
                    context.project(),
                    "Mean&StdDev " + stat["name"],
                    QgsProcessingUtils.LayerHint.Raster,
                )
                layer_details.groupName = NAME["layer_group"]
                layer_details.layerSortKey = 4
                context.addLayerToLoadOnCompletion(stat_out["OutputRasterStats"], layer_details)
                context.layerToLoadOnCompletionDetails(stat_out["OutputRasterStats"]).setPostProcessor(
                    run_alg_styler(
                        "Mean&StdDev " + stat["name"],
                    )
                )
                output_dict[stat["name"] + "Stats"] = stat_out["OutputRasterStats"]

        # grids
        grids = [item for item in SIM_OUTPUTS if item["name"] == "Propagation Fire Scars"][0]
        if sample_file:= next(Path(results_dir).glob(grids["dir"] + "*" + sep + grids["file"] + "*" + grids["ext"]), None):  # fmt: skip
            scar_in_dict = {
                "BaseLayer": base_raster,
                "SampleScarFile": str(sample_file),
                "ScarRaster": QgsProcessing.TEMPORARY_OUTPUT,
                "BurnProbability": QgsProcessing.TEMPORARY_OUTPUT,
            }
            if self.parameterAsBool(parameters, self.POLYSCARS, context):
                scar_in_dict["ScarPolygon"] = QgsProcessing.TEMPORARY_OUTPUT
            scar_out = processing.run(
                "fire2a:scar",
                scar_in_dict,
                context=context,
                feedback=feedback,
                is_child_algorithm=True,
            )
            # final scars raster
            if scar_raster := scar_out.get("ScarRaster"):
                # layer_details = context.layerToLoadOnCompletionDetails(scar_raster)
                layer_details = context.LayerDetails(
                    "Final Scars",
                    context.project(),
                    "Final Scars",
                    QgsProcessingUtils.LayerHint.Raster,
                )
                layer_details.setPostProcessor(run_alg_styler_bin("Final Scars"))
                layer_details.forceName = True
                layer_details.groupName = NAME["layer_group"]
                layer_details.layerSortKey = 1
                context.addLayerToLoadOnCompletion(scar_raster, layer_details)
                output_dict["ScarRaster"] = scar_raster
            # burnprob
            if bplayer := scar_out.get("BurnProbability"):
                # layer_details = context.layerToLoadOnCompletionDetails(bplayer)
                layer_details = context.LayerDetails(
                    "BurnProbability",
                    context.project(),
                    "BurnProbability",
                    QgsProcessingUtils.LayerHint.Raster,
                )
                layer_details.setPostProcessor(run_alg_styler("Burn Probability"))
                layer_details.forceName = True
                layer_details.groupName = NAME["layer_group"]
                layer_details.layerSortKey = 3
                context.addLayerToLoadOnCompletion(bplayer, layer_details)
                output_dict["BurnProbability"] = bplayer
            # grids polygons
            if scar_poly := scar_out.get("ScarPolygon"):
                # feedback.pushDebugInfo(f"{scar_poly=}")
                layer_details = context.LayerDetails(
                    "Propagation Scars",
                    context.project(),
                    "Propagation Scars",
                    QgsProcessingUtils.LayerHint.Vector,
                )
                layer_details.forceName = True
                layer_details.groupName = NAME["layer_group"]
                layer_details.layerSortKey = 3
                context.addLayerToLoadOnCompletion(scar_poly, layer_details)
                output_dict["ScarPolygon"] = scar_poly
                """
                if scar_fixed_geom := processing.run(
                    "native:fixgeometries",
                    {"INPUT": scar_poly, "METHOD": 1, "OUTPUT": QgsProcessing.TEMPORARY_OUTPUT},
                    context=context,
                    feedback=feedback,
                    is_child_algorithm=True,
                ):
                    # feedback.pushDebugInfo(f"{scar_fixed_geom=}")
                    if scar_fixed_geom := scar_fixed_geom.get("OUTPUT"):
                        layer_details = context.LayerDetails(
                            "Propagation Scars",
                            context.project(),
                            "Propagation Scars",
                            QgsProcessingUtils.LayerHint.Vector,
                        )
                        layer_details.forceName = True
                        layer_details.groupName = NAME["layer_group"]
                        layer_details.layerSortKey = 3
                        context.addLayerToLoadOnCompletion(scar_fixed_geom, layer_details)
                        output_dict["ScarPolygon"] = scar_fixed_geom
                """

        # messages
        if self.parameterAsBool(parameters, self.MSGS, context):
            msgs = [item for item in SIM_OUTPUTS if item["name"] == "Propagation Directed Graph"][0]
            if sample_file := next(Path(results_dir, msgs["dir"]).glob(msgs["file"] + "*" + msgs["ext"]), None):
                msg_out = processing.run(
                    "fire2a:propagationdigraph",
                    {
                        "BaseLayer": base_raster,
                        "SampleMessagesFile": str(sample_file),
                        "PropagationDirectedGraph": QgsProcessing.TEMPORARY_OUTPUT,
                    },
                    context=context,
                    feedback=feedback,
                    is_child_algorithm=True,
                )
                layer_details = QgsProcessingContext.LayerDetails(
                    "PropagationDirectedGraph",
                    context.project(),
                    "PropagationDirectedGraph",
                    QgsProcessingUtils.LayerHint.Vector,
                )
                layer_details.groupName = NAME["layer_group"]
                layer_details.layerSortKey = 1
                context.addLayerToLoadOnCompletion(
                    msg_out["PropagationDirectedGraph"],
                    layer_details,
                )
                context.layerToLoadOnCompletionDetails(msg_out["PropagationDirectedGraph"]).setPostProcessor(
                    run_alg_styler_propagation()
                )
                output_dict["PropagationDirectedGraph"] = msg_out["PropagationDirectedGraph"]

        write_log(feedback, name=self.name())
        return output_dict

    def name(self):
        return "simulationresultsprocessing"

    def displayName(self):
        return self.tr("Bundle")

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return "simulatorpostprocessing"

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return PostSimulationAlgorithm()

    def helpString(self):
        return self.shortHelpString()

    def shortHelpString(self):
        return self.tr(
            """This algorithm attempts to load everything from a simulation results directory, in a convenient but slower than selecting one of the following algorithms in the <b>PostProcessing group</b>. Check each one for more details.

            Although <b>Propagation Directed Graph</b> output is fundamental to risk metrics such as DPV and BC: <b>Warning: Enabling it here can hang-up your system</b>, around 300.000 arrows is manageable for a regular laptop<br>
            Be safe by counting them first: Go to results/Messages folder:<br>
             - using bash $ wc -l Messages*csv<br>
             - using PowerShell > Get-Content Messages*.csv | Measure-Object -Line<br>
            To process but not display them, use Propagation DiGraph algorithm directly, unchecking 'Open output file after running algorithm'<br><br>
            <i>The visualization alternative is <b>Propagation Fire Scars</b>. Or even <b>Final Fire Scar</b>, recommended for very large simulations</i>
            """
        )


class MessagesSIMPP(QgsProcessingAlgorithm):
    """Messages Simulation Post Processing Algorithm
    TODO QgsProject.instance().layerTreeRoot().findLayer(layer.id()).setItemVisibilityChecked(False)
    """

    BASE_LAYER = "BaseLayer"
    IN_MSG = "SampleMessagesFile"
    OUTPUT_LAYER = "PropagationDirectedGraph"
    OUT_PICKLED = "PickledMessages"

    def checkParameterValues(self, parameters: dict[str, Any], context: QgsProcessingContext) -> tuple[bool, str]:
        files, msg_dir, msg_name, ext = glob_numbered_files(
            Path(self.parameterAsString(parameters, self.IN_MSG, context))
        )
        if files == []:
            return False, f"{msg_dir} does not contain any non-empty '{msg_name}[0-9]*.{ext}' files"
        return True, ""

    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                name=self.BASE_LAYER,
                description=self.tr("Base raster (normally fuel or elevation) to get the geotransform"),
                defaultValue=[QgsProcessing.TypeRaster],
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterFile(
                name=self.IN_MSG,
                description=(
                    "Sample Messages file (normally firesim_yymmdd_HHMMSS/results/Messages/MessagesFile01.csv)\nAll"
                    " ChosenName[0-9]*.csv files will be loaded"
                ),
                behavior=QgsProcessingParameterFile.File,
                extension="csv",
                defaultValue=None,
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                name=self.OUTPUT_LAYER,
                description=self.tr("Output propagation digraph layer"),
                type=QgsProcessing.TypeVectorLine,
                optional=True,
            )
        )
        qparamfd = QgsProcessingParameterFileDestination(
            name=self.OUT_PICKLED,
            description=self.tr(
                "Output pickled messages file (needed by BC or DPV metrics, defaults to"
                " results/Messages/messages.pickle)"
            ),
            fileFilter="pickled files (*.pickle)",
            # defaultValue=defaultValue,
            optional=True,
            createByDefault=False,
        )
        qparamfd.setMetadata({"widget_wrapper": {"dontconfirmoverwrite": True}})
        self.addParameter(qparamfd)

    def processAlgorithm(self, parameters, context, feedback):
        """Here is where the processing itself takes place."""
        # BASE LAYER
        base_raster = self.parameterAsRasterLayer(parameters, self.BASE_LAYER, context)
        _, raster_props = read_raster(base_raster.publicSource(), data=False)
        feedback.pushDebugInfo(f"base_raster.crs(): {base_raster.crs()}")
        GT = raster_props["Transform"]
        W = raster_props["RasterXSize"]
        H = raster_props["RasterYSize"]
        # set output layer
        fields = QgsFields()
        fields.append(QgsField(name="simulation", type=QVariant.Int, len=10))
        fields.append(QgsField(name="time", type=QVariant.Int, len=10))
        # TODO remove (,)
        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT_LAYER,
            context,
            fields,
            QgsWkbTypes.MultiLineString,  # >v3.3 ? Qgis.WkbType.MultiLineString,
            base_raster.crs(),
        )
        # feedback.pushDebugInfo(f"dest_id: {dest_id}, type: {type(dest_id)}")
        # feedback.pushDebugInfo(f"sink: {sink}, type: {type(sink)}")
        # get messages
        sample_messages_file = Path(self.parameterAsString(parameters, self.IN_MSG, context))
        files, msg_dir, msg_name, ext = glob_numbered_files(sample_messages_file)
        # files, msg_dir, msg_name, ext = get_files(sample_messages_file)
        if files == []:
            feedback.reportError(f"{msg_dir} does not contain any non-empty '{msg_name}[0-9]*{ext}' files")
            raise QgsProcessingException(f"{msg_dir} does not contain any non-empty '{msg_name}[0-9]*{ext}' files")
        feedback.pushDebugInfo(f"{len(files)} messages files, first: {files[0]}...")
        # build digraphs
        data = []
        for count, afile in enumerate(files):
            sim_id = search("\\d+", afile.stem).group(0)
            data += [
                loadtxt(
                    afile, delimiter=",", dtype=[("i", int32), ("j", int32), ("t", int32)], usecols=(0, 1, 2), ndmin=1
                )
            ]
            # 1 based to 0 based
            data[-1]["i"] -= 1
            data[-1]["j"] -= 1
            feedback.pushDebugInfo(f"simulation id: {sim_id}, edges: {len(data)}")
            if sink:
                # build line add to sink
                for i, j, time in data[-1]:
                    i_x_px, i_y_ln = id2xy(i, W, H)
                    i_x_geo, i_y_geo = transform_coords_to_georef(i_x_px + 0.5, i_y_ln + 0.5, GT)
                    # feedback.pushDebugInfo(f"i_x_geo, i_y_geo: {i_x_geo}, {i_y_geo}, time: {time}")
                    j_x_px, j_y_ln = id2xy(j, W, H)
                    j_x_geo, j_y_geo = transform_coords_to_georef(j_x_px + 0.5, j_y_ln + 0.5, GT)
                    # feedback.pushDebugInfo(f"j_x_geo, j_y_geo: {j_x_geo}, {j_y_geo}, time: {time}")
                    # TODO id = int(f"{str(sim_id).zfill(total_sims)}_{i.zfill...}_{j}")
                    feature = QgsFeature(fields)
                    # feature.setId(int(sim_id))
                    feature.setAttributes([int(sim_id), int(time)])
                    feature.setGeometry(QgsLineString([QgsPoint(i_x_geo, i_y_geo), QgsPoint(j_x_geo, j_y_geo)]))
                    sink.addFeature(feature, QgsFeatureSink.FastInsert)
                    # feedback.pushDebugInfo(f"j_x_geo, j_y_geo: {j_x_geo}, {j_y_geo}, time: {time}, sim_idx: {sim_idx}")
                    if feedback.isCanceled():
                        break
            elif feedback.isCanceled():
                break
            feedback.setProgress(int(count * len(files)))

        filename = self.parameterAsFileOutput(parameters, self.OUT_PICKLED, context)
        # feedback.pushCommandInfo(f"filename: {filename}, type: {type(filename)}")
        if filename == "":
            filename = Path(sample_messages_file.parent, "messages.pickle")
        with open(filename, "wb") as f:
            pickle_dump(data, f)

        # handle_post_processing(context, feedback, layer_id=dest_id, style="propagation")
        if context.willLoadLayerOnCompletion(dest_id):
            layer = QgsProcessingUtils.mapLayerFromString(dest_id, context)
            layer_details = context.LayerDetails(
                layer.name(), context.project(), dest_id, QgsProcessingUtils.LayerHint.Vector
            )
            layer_details.groupName = NAME["layer_group"]
            layer_details.layerSortKey = 1
            context.addLayerToLoadOnCompletion(dest_id, layer_details)
            context.layerToLoadOnCompletionDetails(dest_id).setPostProcessor(run_alg_styler_propagation())

        write_log(feedback, name=self.name())
        return {self.OUTPUT_LAYER: dest_id, self.OUT_PICKLED: str(filename)}

    # def postProcessAlgorithm(self, context, feedback):
    #     """Called after processAlgorithm, use it to load the layer and set the symbology"""
    #     feedback.pushDebugInfo(f"postProcessAlgorithm start {context}")
    #     # layer = QgsProcessingUtils.mapLayerFromString(self.dest_id, context)
    #     layer = context.getMapLayer(self.dest_id)
    #     layer.loadNamedStyle(str(Path(assets_dir, "messages.qml")))
    #     # layer.triggerRepaint()
    #     return {self.OUTPUT_LAYER: self.dest_id}

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return MessagesSIMPP()

    def group(self):
        return self.tr("Simulator Post Processing")

    def groupId(self):
        return "simulatorpostprocessing"

    def name(self):
        return "propagationdigraph"

    def displayName(self):
        return self.tr("Propagation DiGraph")

    def icon(self):
        return QIcon(":/plugins/fireanalyticstoolbox/assets/burntime.svg")

    def helpString(self):
        return self.shortHelpString()

    def shortHelpString(self):
        return self.tr(
            "Warning: Uncheck 'Open output file after running algorithm' if the graph is too big or your computer too slow."
        )


class StatisticSIMPP(QgsProcessingAlgorithm):
    """Statistic Simulation Post Processing Algorithm"""

    IN_STAT = "SampleStatisticFile"
    BASE_LAYER = "BaseLayer"
    DATA_TYPE = "DataType"
    OUTPUT_RASTER = "OutputRaster"
    OUTPUT_RASTER_2 = "OutputRasterStats"
    gdal_dt = [GDT_Float32, GDT_Int16]
    numpy_dt = [float32, int16]
    dt_string = ["float32", "int16"]

    def checkParameterValues(self, parameters: dict[str, Any], context: QgsProcessingContext) -> tuple[bool, str]:
        files, stat_dir, stat_name, ext = glob_numbered_files(
            Path(self.parameterAsString(parameters, self.IN_STAT, context))
        )
        # files, stat_dir, stat_name, ext = get_files(Path(self.parameterAsString(parameters, self.IN_STAT, context)))
        if files == []:
            return False, f"{stat_dir} does not contain any non-empty '{stat_name}[0-9]*{ext}' files"
        return True, ""

    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                name=self.BASE_LAYER,
                description=self.tr("Base raster (normally fuel or elevation) to get the geotransform"),
                defaultValue=[QgsProcessing.TypeRaster],
                optional=False,
            )
        )
        known = [item["dir"] + sep + item["file"] for item in STATS]
        self.addParameter(
            QgsProcessingParameterFile(
                name=self.IN_STAT,
                description=(
                    "Sample Spatial Statistic file (normally"
                    " firesim_yymmdd_HHMMSS/results/Statistic/statistic.asc)\nAll ChosenName[0-9]*.asc files will be"
                    " loaded\nKnown: "
                )
                + ", ".join(known),
                behavior=QgsProcessingParameterFile.File,
                extension="asc",
                defaultValue=None,
                optional=False,
            )
        )
        # TODO: RE-IMPLEMENT
        # qppe = QgsProcessingParameterEnum(
        #     name=self.DATA_TYPE,
        #     description=self.tr(
        #         "data type\nSpeed-up processing and lower memory requirements by casting to integers\n(Crown is"
        #         " integer)"
        #     ),
        #     options=self.dt_string,
        #     allowMultiple=False,
        #     defaultValue="float32",
        #     optional=False,
        #     usesStaticStrings=False,
        # )
        # qppe.setFlags(qppe.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        # self.addParameter(qppe)
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                name=self.OUTPUT_RASTER,
                description=self.tr("Output raster"),
                # defaultValue=None,
                # optional=False,
                # createByDefault=True,
            )
        )
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                name=self.OUTPUT_RASTER_2,
                description=self.tr("Output raster mean & std"),
                # defaultValue=None,
                optional=True,
                createByDefault=True,
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """proc algo"""
        feedback.pushDebugInfo(f"processAlgorithm start, parameters: {parameters}, type: {type(parameters)}")
        # get base map
        base_raster = self.parameterAsRasterLayer(parameters, self.BASE_LAYER, context)
        _, raster_props = read_raster(base_raster.publicSource(), data=False)
        feedback.pushDebugInfo(f"base_raster.crs(): {base_raster.crs()}")
        geotransform = raster_props["Transform"]
        W = raster_props["RasterXSize"]
        H = raster_props["RasterYSize"]
        if not (authid := raster_props["Projection"]):
            authid = base_raster.crs().authid()
        feedback.pushDebugInfo(f"base raster properties: {geotransform=}, {W=}, {H=}, {authid=}")

        # get data
        files, stat_dir, stat_name, ext = glob_numbered_files(
            Path(self.parameterAsString(parameters, self.IN_STAT, context))
        )
        # files, stat_dir, stat_name, ext = get_files(Path(self.parameterAsString(parameters, self.IN_STAT, context)))
        if files == []:
            feedback.reportError(f"{stat_dir} does not contain any non-empty '{stat_name}[0-9]*{ext}' files")
            raise QgsProcessingException(f"{stat_dir} does not contain any non-empty '{stat_name}[0-9]*{ext}' files")
        feedback.pushDebugInfo(f"{len(files)} files, first: {files[0]}...")
        # infer dimensional units
        if unit := [item["unit"] for item in STATS if item["file"] == stat_name]:
            unit = unit[0]
        else:
            unit = None

        final_name = ""
        for item in STATS:
            feedback.pushDebugInfo(f"{item=}, {stat_name=}")
            if item["file"] == stat_name:
                final_name = item["name"]
                break
        if final_name == "":
            feedback.reportError(f"Unknown spatial statistic: {stat_name}")
            raise QgsProcessingException(f"Unknown spatial statistic: {stat_name}")

        # out raster
        output_raster_filename = self.parameterAsOutputLayer(parameters, self.OUTPUT_RASTER, context)
        raster_format = get_output_raster_format(output_raster_filename, feedback)
        feedback.pushDebugInfo(f"{output_raster_filename=}, {raster_format=}")

        output_raster2_filename = self.parameterAsOutputLayer(parameters, self.OUTPUT_RASTER_2, context)
        raster_format = get_output_raster_format(output_raster2_filename, feedback)
        feedback.pushDebugInfo(f"{output_raster2_filename=}, {raster_format=}")

        # dtype
        # data_type_idx = self.parameterAsEnum(parameters, self.DATA_TYPE, context)
        # feedback.pushDebugInfo(
        #     f"data_type_idx: {data_type_idx}, {self.gdal_dt[data_type_idx]}, {self.numpy_dt[data_type_idx]}"
        # )

        def callback(progress=None, message=None):
            if progress:
                feedback.setProgress(progress)
            if message:
                feedback.setProgressText(message)
            if feedback.isCanceled():
                raise QgsProcessingException("Algorithm cancelled by user")

        # from importlib import reload

        # from fire2a import cell2fire

        # reload(cell2fire)
        from fire2a.cell2fire import build_stats

        try:
            build_stats(
                output_raster_filename,
                output_raster2_filename if len(files) > 1 else None,
                Path(self.parameterAsString(parameters, self.IN_STAT, context)),
                W,
                H,
                geotransform,
                authid,
                callback,
                feedback,
            )
        except Exception as e:
            feedback.reportError(f"Build Scars failed! {e}")
            raise QgsProcessingException(f"Build Scars failed! {e}")

        output_dict = {}
        if output_raster_filename:
            output_dict[self.OUTPUT_RASTER] = output_raster_filename
            if context.willLoadLayerOnCompletion(output_raster_filename):
                # attach post processor
                # display_name = f"{stat_name}_{self.numpy_dt[data_type_idx].__name__}"
                display_name = f"{final_name}"
                # known = [item["dir"] + sep + item["file"] for item in STATS]
                layer_details = context.LayerDetails(
                    display_name, context.project(), display_name, QgsProcessingUtils.LayerHint.Raster
                )
                layer_details.groupName = NAME["layer_group"]
                layer_details.layerSortKey = 2
                context.addLayerToLoadOnCompletion(output_raster_filename, layer_details)
                context.layerToLoadOnCompletionDetails(output_raster_filename).setPostProcessor(
                    run_alg_styler(
                        display_name,
                    )
                )

        if output_raster2_filename:
            if len(files) == 1:
                from shutil import copy

                copy(output_raster_filename, output_raster2_filename)
                feedback.pushWarning(f"Only one file for statistic raster {output_raster2_filename} doesnt make sense!")
            output_dict[self.OUTPUT_RASTER_2] = output_raster2_filename
            # rename if showing
            if context.willLoadLayerOnCompletion(output_raster2_filename):
                layer_details = context.layerToLoadOnCompletionDetails(output_raster2_filename)
                # layer_details.name = f"{stat_name}_mean&std_{self.numpy_dt[data_type_idx].__name__}"
                layer_details.name = f"{final_name} mean&std"
                layer_details.groupName = NAME["layer_group"]
                layer_details.layerSortKey = 3

        write_log(feedback, name=self.name())
        return output_dict

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return StatisticSIMPP()

    def group(self):
        return self.tr("Simulator Post Processing")

    def groupId(self):
        return "simulatorpostprocessing"

    def name(self):
        return "statistic"

    def displayName(self):
        return self.tr("Spatial Statistic")

    def icon(self):
        return QIcon(":/plugins/fireanalyticstoolbox/assets/fireface.svg")

    def helpString(self):
        return self.shortHelpString()

    def shortHelpString(self):
        return self.tr(
            """
            This post processing algorithm, reads the raw output of C2F-W simulator and generates two rasters.
            One has one band per simulation, named "StatName" (so N bands for N simulations), e.g., Surface Flame Lenght
            
            The second one has two bands corresponding to the mean and standard deviation, e.g., "Mean&StdDev Hit Rate Of Spread".
            The <b>mean statistic</b> sums, for each pixel, its values divided by <b>burnt count</b>. 
            The <b>standard deviation</b> divides against <b>all simulations</b>, not burnt count of each individual pixel.

            Check the <a href=https://fire2a.github.io/docs/qgis-toolbox/algo_simulator.html#options>table below<a/> for more info
            """
        )


class ScarSIMPP(QgsProcessingAlgorithm):
    """Fire scar Simulation Post Processing Algorithm"""

    IN_SCAR = "SampleScarFile"
    BASE_LAYER = "BaseLayer"
    IN_FIXGEOM = "FixGeometries"
    IN_FIXGEOM_METHOD = "FixGeometriesMethod"
    OUT_RASTER = "ScarRaster"
    OUT_POLY = "ScarPolygon"
    OUT_BP = "BurnProbability"

    def checkParameterValues(self, parameters: dict[str, Any], context: QgsProcessingContext) -> tuple[bool, str]:
        from fire2a.cell2fire import get_scars_files

        retval, msg, root, parent_dirs, parent_ids, files, children_ids = get_scars_files(
            Path(self.parameterAsString(parameters, self.IN_SCAR, context))
        )
        if not retval:
            return False, msg
        if files == []:
            return False, f"{root} does not contain any non-empty scar files"
        scar_raster = self.parameterAsOutputLayer(parameters, self.OUT_RASTER, context)
        burn_prob = self.parameterAsOutputLayer(parameters, self.OUT_BP, context)
        scar_poly = self.parameterAsOutputLayer(parameters, self.OUT_POLY, context)
        for afile in [scar_raster, burn_prob]:
            if afile != "":
                ext = Path(afile).suffix[1:]
                if ext not in QgsRasterFileWriter.supportedFormatExtensions(QgsRasterFileWriter.RasterFormatOptions()):
                    return False, f"{self.OUT_RASTER} format .{ext} not supported"
        if scar_poly == "" and scar_raster == "" and burn_prob == "":
            return False, "No output selected!"
        return True, ""

    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                name=self.BASE_LAYER,
                description=self.tr("Base raster (normally fuel or elevation) to get the geotransform"),
                defaultValue=[QgsProcessing.TypeRaster],
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterFile(
                name=self.IN_SCAR,
                description=(
                    "Sample Fire Scar file (normally"
                    " firesim_yymmdd_HHMMSS/results/Grids/Grids[0-9]*/ForestGrid[0-9]*.csv)"
                ),
                behavior=QgsProcessingParameterFile.File,
                extension="csv",
                defaultValue=None,
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                name=self.OUT_RASTER,
                description=self.tr("Output final scar raster"),
                optional=True,
                createByDefault=True,
            )
        )
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                name=self.OUT_POLY,
                description=self.tr("Output propagation scars polygons"),
                type=QgsProcessing.TypeVectorPolygon,
                optional=True,
                createByDefault=True,
            )
        )
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                name=self.OUT_BP,
                description=self.tr("Output burn probability raster"),
                optional=True,
                createByDefault=True,
            )
        )
        qppb = QgsProcessingParameterBoolean(
            name=self.IN_FIXGEOM,
            description=("Fix geometries of the generated propagation polygons (native:fixgeometries)"),
            defaultValue=True,
            optional=True,
        )
        qppb.setFlags(qppb.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(qppb)
        qppn = QgsProcessingParameterNumber(
            name=self.IN_FIXGEOM_METHOD,
            description=("Repair method passed to fix geometries (0:Linework, 1:Structure didn't work on MacOS)"),
            defaultValue=0 if platform_system() == "Darwin" else 1,
            optional=True,
        )
        qppn.setFlags(qppn.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(qppn)

    def processAlgorithm(self, parameters, context, feedback):
        """Here is where the processing itself takes place."""
        # feedback.pushDebugInfo("processAlgorithm start")
        output_dict = {self.OUT_RASTER: "", self.OUT_POLY: "", self.OUT_BP: ""}
        # get base map
        base_raster = self.parameterAsRasterLayer(parameters, self.BASE_LAYER, context)
        _, raster_props = read_raster(base_raster.publicSource(), data=False)
        geotransform = raster_props["Transform"]
        W = raster_props["RasterXSize"]
        H = raster_props["RasterYSize"]
        if not (authid := raster_props["Projection"]):
            authid = base_raster.crs().authid()
        feedback.pushDebugInfo(f"base raster properties: {geotransform=}, {W=}, {H=}, {authid=}")

        sample_file = Path(self.parameterAsString(parameters, self.IN_SCAR, context))
        output_raster_filename = self.parameterAsOutputLayer(parameters, self.OUT_RASTER, context)
        output_vector_file = self.parameterAsFileOutput(parameters, self.OUT_POLY, context)
        burn_prob_fname = self.parameterAsOutputLayer(parameters, self.OUT_BP, context)
        feedback.pushDebugInfo(f"{sample_file=}, {output_raster_filename=}, {output_vector_file=}, {burn_prob_fname=}")
        # if output_vector_file[-5:] != ".gpkg":
        #     output_vector_file = output_vector_file + ".gpkg"

        fix_geo = self.parameterAsBool(parameters, self.IN_FIXGEOM, context)
        fix_geo_method = self.parameterAsInt(parameters, self.IN_FIXGEOM_METHOD, context)
        feedback.pushDebugInfo(f"{fix_geo=}, {fix_geo_method=}")

        def callback(progress=None, message=None):
            if progress:
                feedback.setProgress(progress)
            if message:
                feedback.setProgressText(message)
            if feedback.isCanceled():
                raise QgsProcessingException("Algorithm cancelled by user")

        # from importlib import reload

        # from fire2a import cell2fire

        # reload(cell2fire)
        from fire2a.cell2fire import build_scars

        try:
            build_scars(
                output_raster_filename,
                output_vector_file,
                burn_prob_fname,
                sample_file,
                W,
                H,
                geotransform,
                authid,
                callback,
                feedback,
            )
        except Exception as e:
            feedback.reportError(f"Build Scars failed! {e}")
            raise QgsProcessingException(f"Build Scars failed! {e}")

        if output_raster_filename:
            if context.willLoadLayerOnCompletion(output_raster_filename):
                layer_details = context.layerToLoadOnCompletionDetails(output_raster_filename)
                layer_details.setPostProcessor(run_alg_styler_bin("Final Scars"))
                layer_details.groupName = NAME["layer_group"]
                layer_details.layerSortKey = 2
            output_dict[self.OUT_RASTER] = output_raster_filename

        if burn_prob_fname:
            if context.willLoadLayerOnCompletion(burn_prob_fname):
                layer_name = "Burn Probability"
                layer_details = context.LayerDetails(
                    layer_name,
                    context.project(),
                    layer_name,
                    QgsProcessingUtils.LayerHint.Raster,
                )
                layer_details.groupName = NAME["layer_group"]
                layer_details.layerSortKey = 4
                context.addLayerToLoadOnCompletion(burn_prob_fname, layer_details)
                context.layerToLoadOnCompletionDetails(burn_prob_fname).setPostProcessor(
                    run_alg_styler(
                        layer_name,
                        layer_bands=1,
                    )
                )
            output_dict["BurnProbability"] = burn_prob_fname

        if output_vector_file:
            if fix_geo:
                if fix_geo_run := processing.run(
                    "native:fixgeometries",
                    {
                        "INPUT": output_vector_file,  # "memory:ds" otrolyr "memory:tmp"
                        "METHOD": fix_geo_method,
                        "OUTPUT": output_vector_file,  # QgsProcessing.TEMPORARY_OUTPUT
                    },
                    context=context,
                    feedback=feedback,
                    is_child_algorithm=True,
                ):
                    if fix_geo_out := fix_geo_run.get("OUTPUT"):
                        feedback.pushInfo(f"Fixing geometries done! {fix_geo_out}")
                        output_vector_file = fix_geo_out
            layer_details = context.LayerDetails(
                "Propagation Scars",
                context.project(),
                "Propagation Scars",
                QgsProcessingUtils.LayerHint.Vector,
            )
            layer_details.forceName = True
            layer_details.groupName = NAME["layer_group"]
            layer_details.layerSortKey = 2
            context.addLayerToLoadOnCompletion(output_vector_file, layer_details)
            output_dict[self.OUT_POLY] = output_vector_file

        write_log(feedback, name=self.name())
        return output_dict

    def name(self):
        return "scar"

    def displayName(self):
        return self.tr("Fire Scar")

    def group(self):
        return self.tr("Simulator Post Processing")

    def groupId(self):
        return "simulatorpostprocessing"

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return ScarSIMPP()

    def icon(self):
        return QIcon(":/plugins/fireanalyticstoolbox/assets/bodyscar.svg")

    def helpString(self):
        return self.shortHelpString()

    def shortHelpString(self):
        return self.tr(
            """ - Input <b>Sample</b> Fire Scar is any of the ForestGrid files; with it a pattern search for all Grids(any digit)/ForestGrid(any digit).csv will be performed.
            - Output <b>Final</b> Scar raster needs simulation ran with Final Fire Scar option, each band is a simulation
            - Output <b>Burn Probability</b> raster is the mean of all simulations, requires >1 simulations
            - Output <b>Propagation</b> Scars Polygons accumulates fixed-geometry, polygonized, in-memory rasters (4 steps); attributing for each one its: simulation, period, perimeter and area. This is known to fail in some qgis-versions, OSes or low RAM hardware. Mitigations:
            A. Change the default .gpkg format to .shp or test other
            B. Use the advanced options to tweak or disable the fix geometries option
            C. <b>Skip this output altogether by clicking the option button '...' and selecting Skip Output</b>

            <i>If the Bundle algorithm failed for you, this propagation output is the most likely cause...</i>"""
        )


class BurnProbabilityMetric(QgsProcessingAlgorithm):
    """Cell2Fire results post processing bundle"""

    BASE_LAYER = "BaseLayer"
    IN_SCAR = "SampleScarFile"
    OUT_BP = "BurnProbability"

    def initAlgorithm(self, config):
        """inputs and output of the algorithm"""
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                name=self.BASE_LAYER,
                description=self.tr("Base raster (normally fuel or elevation) to get the geotransform"),
                defaultValue=[QgsProcessing.TypeRaster],
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterFile(
                name=self.IN_SCAR,
                description=(
                    "Sample Fire Scar file (normally"
                    " firesim_yymmdd_HHMMSS/results/Grids/Grids[0-9]*/ForestGrid[0-9]*.csv)"
                ),
                behavior=QgsProcessingParameterFile.File,
                extension="csv",
                defaultValue=None,
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                name=self.OUT_BP,
                description=self.tr("Output burn probability raster"),
                optional=True,
                createByDefault=True,
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """Here is where the processing itself takes place."""
        # feedback.pushDebugInfo("processAlgorithm start")
        # feedback.pushDebugInfo(f"context args: {context.asQgisProcessArguments()}")
        # feedback.pushDebugInfo(f"parameters {parameters}")
        output_dict = {}

        scar_out = processing.run(
            "fire2a:scar",
            {
                "BaseLayer": self.parameterAsRasterLayer(parameters, self.BASE_LAYER, context),
                "SampleScarFile": self.parameterAsString(parameters, self.IN_SCAR, context),
                "BurnProbability": self.parameterAsOutputLayer(parameters, self.OUT_BP, context),
            },
            context=context,
            feedback=feedback,
            is_child_algorithm=True,
        )
        # burnprob
        if bplayer := scar_out.get("BurnProbability"):
            # layer_details = context.layerToLoadOnCompletionDetails(bplayer)
            layer_details = context.LayerDetails(
                "BurnProbability",
                context.project(),
                "BurnProbability",
                QgsProcessingUtils.LayerHint.Raster,
            )
            layer_details.setPostProcessor(run_alg_styler("Burn Probability"))
            layer_details.forceName = True
            layer_details.groupName = NAME["layer_group"]
            layer_details.layerSortKey = 3
            context.addLayerToLoadOnCompletion(bplayer, layer_details)
            output_dict["BurnProbability"] = bplayer

        write_log(feedback, name=self.name())
        return output_dict

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def group(self):
        return self.tr(NAME["simm"])

    def groupId(self):
        return jolo(NAME["simm"])

    def name(self):
        return jolo(NAME["bp"])

    def displayName(self):
        return self.tr(NAME["bp"])

    def createInstance(self):
        return BurnProbabilityMetric()

    def helpString(self):
        return self.shortHelpString()

    def shortHelpString(self):
        return self.tr(
            """Burn probabilty raster is the mean of all simulations<br>
            It's the same as using the 'Fire Scar' algorithm, skipping output for scars and polygons, leaving only the 'Burn Probability' output enabled<br>
            From a simulation results directory, select the 'Grids' directory and choose any of the 'ForestGrid' files
            """
        )

    def icon(self):
        return QIcon(":/plugins/fireanalyticstoolbox/assets/bodyscar.svg")


def run_alg_styler_propagation():
    """Create a New Post Processor class and returns it"""

    class LayerPostProcessor(QgsProcessingLayerPostProcessorInterface):
        instance = None

        def postProcessLayer(self, layer, context, feedback):
            if layer.isValid():
                # QgsProject.instance().layerTreeRoot().findLayer(layer.id()).setItemVisibilityChecked(False)
                processing.run(
                    "qgis:setstyleforvectorlayer",
                    {"INPUT": layer, "STYLE": str(Path(assets_dir, "messages.qml"))},
                    context=context,
                    feedback=feedback,
                    is_child_algorithm=True,
                )
                renderer = layer.renderer()
                # FIXME DeprecationWarning
                renderer.updateClasses(layer, QgsGraduatedSymbolRenderer.Mode.Jenks, 10)
                # enum : EqualInterval , Quantile , Jenks , StdDev , Pretty , Custom
                # layer.triggerRepaint()
                layer.setSubsetString('"time"<=120  AND "simulation" = 1')
                QgsMessageLog.logMessage(f"propagation styling done! {layer.name()}", TAG, Qgis.Info)
            else:
                QgsMessageLog.logMessage(
                    f"propagation styling failed! layer not valid: {layer.name()}", TAG, Qgis.Critical
                )

        # Hack to work around sip bug!
        @staticmethod
        def create() -> "LayerPostProcessor":
            LayerPostProcessor.instance = LayerPostProcessor()
            return LayerPostProcessor.instance

    return LayerPostProcessor.create()


def run_alg_styler_bin(display_name, layer_bands=1):
    """Create a New Post Processor class and returns it"""

    class LayerPostProcessor(QgsProcessingLayerPostProcessorInterface):
        instance = None
        name = display_name
        bands = layer_bands

        lst = [
            QgsColorRampShader.ColorRampItem(0, QColor(2, 2, 2)),
            QgsColorRampShader.ColorRampItem(1, QColor(222, 222, 222)),
        ]
        class_data = QgsPalettedRasterRenderer.colorTableToClassData(lst)  # <-

        def postProcessLayer(self, layer, context, feedback):
            feedback.pushInfo(f"Inside postProcessLayer: {self.name}")
            if layer.isValid():
                prov = layer.dataProvider()
                layer.setName(self.name)
                feedback.pushInfo(f"Layer valid, set name: {self.name}")
                for band in range(1, self.bands + 1):
                    renderer = QgsPalettedRasterRenderer(prov, band, self.class_data)
                    layer.setRenderer(renderer)
            else:
                feedback.pushInfo(f"Layer not valid: {self.name}")

        # Hack to work around sip bug!
        @staticmethod
        def create() -> "LayerPostProcessor":
            LayerPostProcessor.instance = LayerPostProcessor()
            return LayerPostProcessor.instance

    return LayerPostProcessor.create()


def run_alg_styler(
    display_name,
    layer_color1=(68, 1, 84),
    layer_color2=(253, 231, 37),
    layer_min_val=None,
    layer_max_val=None,
    layer_bands=None,
):
    """Create a New Post Processor class and returns it

    # Just simply creating a new instance of the class was not working
    # for details see https://gis.stackexchange.com/questions/423650/qgsprocessinglayerpostprocessorinterface-only-processing-the-last-layer
    """

    class LayerPostProcessor(QgsProcessingLayerPostProcessorInterface):
        instance = None
        name = display_name
        color1 = layer_color1
        color2 = layer_color2
        min_val = layer_min_val
        max_val = layer_max_val
        bands = layer_bands

        def postProcessLayer(self, layer, context, feedback):
            feedback.pushInfo(f"Inside postProcessLayer: {self.name}")
            if layer.isValid():
                prov = layer.dataProvider()
                if self.min_val is None or self.max_val is None:
                    stats = prov.bandStatistics(1, QgsRasterBandStats.All, layer.extent(), 0)
                    self.min_val = stats.minimumValue if self.min_val is None else self.min_val
                    self.max_val = stats.maximumValue if self.max_val is None else self.max_val
                if self.bands is None:
                    self.bands = layer.bandCount()
                feedback.pushInfo(f"Layer valid: {self.name}")
                layer.setName(self.name)
                for band in range(1, self.bands + 1)[::-1]:
                    fcn = QgsColorRampShader()
                    fcn.setColorRampType(QgsColorRampShader.Interpolated)
                    lst = [
                        QgsColorRampShader.ColorRampItem(self.min_val, QColor(*self.color1)),
                        QgsColorRampShader.ColorRampItem(self.max_val, QColor(*self.color2)),
                    ]
                    fcn.setColorRampItemList(lst)
                    shader = QgsRasterShader()
                    shader.setRasterShaderFunction(fcn)
                    # windows error argument 1 has unexpected type 'QgsMeshDataProvider'
                    renderer = QgsSingleBandPseudoColorRenderer(prov, band, shader)
                    layer.setRenderer(renderer)
                # renderer = QgsSingleBandPseudoColorRenderer(layer.dataProvider(), 1, shader)
                # layer.setRenderer(renderer)
            else:
                feedback.pushInfo(f"Layer not valid: {self.name}")

        # Hack to work around sip bug!
        @staticmethod
        def create() -> "LayerPostProcessor":
            LayerPostProcessor.instance = LayerPostProcessor()
            return LayerPostProcessor.instance

    return LayerPostProcessor.create()


class Renamer(QgsProcessingLayerPostProcessorInterface):
    def __init__(self, layer_name):
        super().__init__()
        self.name = layer_name

    def postProcessLayer(self, layer, context, feedback):
        if layer.isValid():
            layer.setName(self.name)


class BetweennessCentralityMetric(QgsProcessingAlgorithm):
    """Messages Simulation Post Processing Algorithm"""

    BASE_LAYER = "BaseLayer"
    IN = "PickledMessages"
    IN_def_k = "UseDefaultInputSamples"
    IN_k = "InputSamples"
    IN_seed = "InputSamplesRNGSeed"
    OUT_R = "BetweennessCentralityRaster"

    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                name=self.BASE_LAYER,
                description=self.tr("Base raster (normally fuel or elevation) to get the geotransform"),
                defaultValue=[QgsProcessing.TypeRaster],
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterFile(
                name=self.IN,
                description=(
                    "Pickled messages (normally generated by the Propagation Digraph Algorithm"
                    " results/Messages/messages.pickle)"
                ),
                behavior=QgsProcessingParameterFile.File,
                extension="pickle",
                defaultValue=None,
                optional=False,
            )
        )
        qppb = QgsProcessingParameterBoolean(
            name=self.IN_def_k,
            description=self.tr("Use default sampling ratio K = sqrt(number_of_nodes)/5"),
            defaultValue=True,
            optional=False,
        )
        qppb.setFlags(qppb.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(qppb)
        qppn = QgsProcessingParameterNumber(
            name=self.IN_k,
            description=self.tr(
                "K samples to estimate betweenness."
                "\n Not set and disabled default sampling checkbox means all nodes are used: very slow!"
                "\n Trade-off between accuracy and running time."
            ),
            type=QgsProcessingParameterNumber.Integer,
            # defaultValue = 0, # <- no se puede quitar
            optional=True,
            minValue=1,
            # maxValue=13,
        )
        qppn.setFlags(qppn.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(qppn)
        qppn2 = QgsProcessingParameterNumber(
            name=self.IN_seed,
            description=self.tr("Random number generator seed for sampling. Used if K is not set."),
            type=QgsProcessingParameterNumber.Integer,
            defaultValue=42,
            optional=False,
            # minValue=1,
            # maxValue=13,
        )
        qppn2.setFlags(qppn2.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(qppn2)
        # self.addParameter(
        #     QgsProcessingParameterFeatureSink(
        #         name=self.OUT_L,
        #         description=self.tr("Output BC layer"),
        #         type=QgsProcessing.TypeVectorLine,
        #         optional=True,
        #         createByDefault=True,
        #     )
        # )
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                name=self.OUT_R,
                description=self.tr("Output BC raster"),
                # defaultValue=None,
                # optional=False,
                # createByDefault=True,
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """Here is where the processing itself takes place."""
        # BASE LAYER
        base_raster = self.parameterAsRasterLayer(parameters, self.BASE_LAYER, context)
        _, raster_props = read_raster(base_raster.publicSource(), data=False)
        feedback.pushDebugInfo(f"base_raster.crs(): {base_raster.crs()}")
        GT = raster_props["Transform"]
        W = raster_props["RasterXSize"]
        H = raster_props["RasterYSize"]

        data_file = Path(self.parameterAsString(parameters, self.IN, context))
        with open(data_file, "rb") as f:
            data_list = pickle_load(f)
        feedback.pushDebugInfo(f"data_file: {data_file}, len(data_list): {len(data_list)}")

        mdg = MultiDiGraph()
        func = vectorize(lambda x: {"weight": x})
        for k, data in enumerate(data_list):
            # ebunch_to_add : container of 4-tuples (u, v, k, d) for an edge with data and key k
            bunch = vstack((data["i"], data["j"], [k] * len(data), func(data["t"]))).T
            mdg.add_edges_from(bunch)
            if feedback.isCanceled():
                break

        if self.parameterAsBool(parameters, self.IN_def_k, context):
            ksample = int(sqrt(mdg.number_of_nodes() * 5))
        elif self.parameterAsBool(parameters, self.IN_k, context):
            ksample = self.parameterAsInt(parameters, self.IN_k, context)
        else:
            ksample = mdg.number_of_nodes()
        seed = self.parameterAsInt(parameters, self.IN_seed, context)
        feedback.pushDebugInfo(f"ksample: {ksample}, out of {mdg.number_of_nodes()} nodes, seed: {seed}")
        centrality = betweenness_centrality(mdg, k=ksample, weight="weight", seed=seed)

        centrality_array = zeros((H, W), dtype=float32)
        centrality_values = []
        for cell, value in centrality.items():
            i, j = id2xy(cell, W, H)
            centrality_array[j, i] = value
            centrality_values += [value]

        # raster
        output_raster_filename = self.parameterAsOutputLayer(parameters, self.OUT_R, context)
        raster_format = get_output_raster_format(output_raster_filename, feedback)
        feedback.pushDebugInfo(f"output_raster: {output_raster_filename}, {raster_format}")

        dst_ds = gdal.GetDriverByName(raster_format).Create(output_raster_filename, W, H, 1, GDT_Float32)
        dst_ds.SetGeoTransform(GT)  # specify coords
        dst_ds.SetProjection(base_raster.crs().authid())  # export coords to file
        band = dst_ds.GetRasterBand(1)
        band.SetUnitType("centrality")
        if 0 != band.SetNoDataValue(0):
            feedback.pushWarning(f"Set No Data failed for {self.OUT_R}")
        if 0 != band.WriteArray(centrality_array):
            feedback.pushWarning(f"WriteArray failed for {self.OUT_R}")

        centrality_stats = scipy_stats.describe(centrality_values, axis=None)
        stats_min, stats_max = centrality_stats.minmax
        feedback.pushInfo(f"centrality values stats: {centrality_stats}")

        if context.willLoadLayerOnCompletion(output_raster_filename):
            # attach post processor
            display_name = f"{self.OUT_R}"
            layer_details = context.LayerDetails(
                display_name, context.project(), display_name, QgsProcessingUtils.LayerHint.Raster
            )
            layer_details.groupName = NAME["layer_group"]
            layer_details.layerSortKey = 3
            context.addLayerToLoadOnCompletion(output_raster_filename, layer_details)
            context.layerToLoadOnCompletionDetails(output_raster_filename).setPostProcessor(
                run_alg_styler(
                    display_name,
                    layer_min_val=stats_min,
                    layer_max_val=stats_max,
                    layer_bands=1,
                )
            )
        write_log(feedback, name=self.name())
        return {self.OUT_R: output_raster_filename}

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return BetweennessCentralityMetric()

    def group(self):
        return self.tr(NAME["simm"])

    def groupId(self):
        return jolo(NAME["simm"])

    def name(self):
        return jolo(NAME["bc"])

    def displayName(self):
        return self.tr(NAME["bc"])

    def icon(self):
        return QIcon(":/plugins/fireanalyticstoolbox/assets/bc.svg")


def recursion(G: DiGraph, i: int32, mdpv: ndarray, i2n: list[int]) -> ndarray:
    for j in G.successors(i):
        mdpv[i2n.index(i)] += recursion(G, j, mdpv, i2n)
    return mdpv[i2n.index(i)]


def worker(data, pv, sid):
    # digraph_from_messages(msgfile) -> msgG, root
    msgG = DiGraph()
    msgG.add_weighted_edges_from(data)
    root = data[0][0]
    # shortest_propagation_tree(G, root) -> treeG
    shortest_paths = single_source_dijkstra_path(msgG, root, weight="time")
    del shortest_paths[root]
    treeG = DiGraph()
    for node, shopat in shortest_paths.items():
        for i, node in enumerate(shopat[:-1]):
            treeG.add_edge(node, shopat[i + 1])
    # dpv_maskG(G, root, pv, i2n) -> mdpv
    i2n = [n for n in treeG]
    mdpv = pv[i2n]
    recursion(treeG, root, mdpv, i2n)
    # dpv[i2n] += mdpv
    return mdpv, i2n, sid


def shout_progress(result, feedback):
    _, i2n, sid = result
    feedback.pushDebugInfo(f"Processed simulation {sid}, modified cells {len(i2n)}")


class DownStreamProtectionValueMetric(QgsProcessingAlgorithm):
    """Messages Simulation Post Processing Algorithm"""

    BASE_LAYER = "ProtectionValueRaster"
    IN = "PickledMessages"
    OUT_R = "RasterOutput"
    IN_THREADS = "Threads"
    IN_FILL = "NoBurnFill"
    IN_SCALE = "Scaling"

    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                name=self.BASE_LAYER,
                description=self.tr("Protection Value Raster (get values & geotransform)"),
                defaultValue=[QgsProcessing.TypeRaster],
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterFile(
                name=self.IN,
                description=(
                    "Pickled messages (normally generated by the Propagation Digraph Algorithm"
                    " results/Messages/messages.pickle)"
                ),
                behavior=QgsProcessingParameterFile.File,
                extension="pickle",
                defaultValue=None,
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                name=self.OUT_R,
                description=self.tr("Output raster"),
                # defaultValue=None,
                optional=False,
                createByDefault=True,
            )
        )
        # advanced
        qppn = QgsProcessingParameterNumber(
            name=self.IN_THREADS,
            description=self.tr("Maximum number of threads to use simultaneously"),
            type=QgsProcessingParameterNumber.Integer,
            defaultValue=cpu_count() - 1,
            optional=True,
            minValue=1,
            maxValue=cpu_count(),
        )
        qppn.setFlags(qppn.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(qppn)
        qppb = QgsProcessingParameterBoolean(
            name=self.IN_FILL,
            description=("Include original protection values where no fire was seen (default true)"),
            defaultValue=True,
            optional=True,
        )
        qppb.setFlags(qppb.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(qppb)
        qppb1 = QgsProcessingParameterBoolean(
            name=self.IN_SCALE,
            description=(
                "Scale every pixel by burn count (default true); or all pixels by number of simulations (false)"
            ),
            defaultValue=True,
            optional=True,
        )
        qppb1.setFlags(qppb1.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(qppb1)

    def processAlgorithm(self, parameters, context, feedback):
        """Here is where the processing itself takes place."""
        # BASE LAYER
        base_raster = self.parameterAsRasterLayer(parameters, self.BASE_LAYER, context)
        pv, raster_props = read_raster(base_raster.publicSource(), data=True)
        feedback.pushDebugInfo(f"base_raster.crs().authid(): {base_raster.crs().authid()}")
        GT = raster_props["Transform"]
        W = raster_props["RasterXSize"]
        H = raster_props["RasterYSize"]
        nodata = raster_props["NoDataValue"]

        data_file = Path(self.parameterAsString(parameters, self.IN, context))
        with open(data_file, "rb") as f:
            data_list = pickle_load(f)
        feedback.pushDebugInfo(f"data_file: {data_file}, len(data_list): {len(data_list)}")
        nsim = len(data_list)

        pv = pv.ravel()
        if nodata:
            pv[pv == nodata] = 0
        dpv = zeros(pv.shape, dtype=pv.dtype)
        burn_count = zeros(pv.shape, dtype=pv.dtype)

        if platform_system() == "Windows":
            feedback.pushWarning("MsWindows detected! Using the serial DPV calculation, switch to Linux to parallelize")
            for count, data in enumerate(data_list):
                # digraph_from_messages(msgfile) -> msgG, root
                msgG = DiGraph()
                msgG.add_weighted_edges_from(data)
                root = data[0][0]  # checkar que el primer valor del message sea el punto de ignición
                # shortest_propagation_tree(G, root) -> treeG
                shortest_paths = single_source_dijkstra_path(msgG, root, weight="time")
                del shortest_paths[root]
                treeG = DiGraph()
                for node, shopat in shortest_paths.items():
                    for i, node in enumerate(shopat[:-1]):
                        treeG.add_edge(node, shopat[i + 1])
                # dpv_maskG(G, root, pv, i2n) -> mdpv
                i2n = [n for n in treeG]  # TODO change to generator?
                mdpv = pv[i2n]
                recursion(treeG, root, mdpv, i2n)
                dpv[i2n] += mdpv
                burn_count[i2n] += 1
                feedback.setProgress((count + 1) / nsim * 100)
                if feedback.isCanceled():
                    break
        else:
            # multiprocessing
            threads = self.parameterAsEnum(parameters, self.IN_THREADS, context)
            feedback.pushDebugInfo(f"Orchestrating {nsim} processes in a {threads}-lane parallel execution pool")
            pool = Pool(threads)
            results = [
                pool.apply_async(worker, args=(data, pv, i), callback=partial(shout_progress, feedback=feedback))
                for i, data in enumerate(data_list)
            ]
            while True:
                # user canceled?
                if feedback.isCanceled():
                    feedback.pushWarning("Canceling...")
                    pool.terminate()
                    return {}
                # all done?
                statuses = [result.ready() for result in results]
                if all(statuses):
                    break
                feedback.setProgress(int(100 * sum(statuses) / nsim))
                # wait
                results[statuses.index(False)].wait(1)
            # retrieve
            for result in results:
                sdpv, si2n, sid = result.get()
                dpv[si2n] += sdpv
                burn_count[si2n] += 1
                # feedback.pushDebugInfo(f"accumulated dpv sum -per simulation {sid}: {dpv.sum()}")
            pool.close()
            pool.join()

        feedback.pushDebugInfo("End parallel part")
        # fill places where no fire was recorded
        if self.parameterAsBool(parameters, self.IN_FILL, context):
            mask = (dpv == 0) & (pv != 0)
            perc = mask.sum() / len(mask) * 100
            feedback.pushDebugInfo(f"Completing {perc:.2f} % of landscape that never burned")
            dpv[mask] = pv[mask]
        # scale
        if self.parameterAsBool(parameters, self.IN_SCALE, context):
            burned_mask = burn_count != 0
            dpv[burned_mask] = dpv[burned_mask] / burn_count[burned_mask]
        else:
            dpv = dpv / nsim
        # descriptive statistics
        if np_any(dpv[dpv != 0]):
            dpv_stats = scipy_stats.describe(dpv[dpv != 0.0], axis=None)
            msg = "(!=0)"
        else:
            dpv_stats = scipy_stats.describe(dpv, axis=None)
            feedback.pushWarning("Calculated Downstream Protection Value is zero all around!")
            msg = ""
        stats_min, stats_max = dpv_stats.minmax
        feedback.pushInfo(f"stats {msg}: {dpv_stats}")
        # raster
        output_raster_filename = self.parameterAsOutputLayer(parameters, self.OUT_R, context)
        raster_format = get_output_raster_format(output_raster_filename, feedback)
        feedback.pushDebugInfo(f"output_raster: {output_raster_filename}, {raster_format}")

        dst_ds = gdal.GetDriverByName(raster_format).Create(output_raster_filename, W, H, 1, GDT_Float32)
        dst_ds.SetGeoTransform(GT)  # specify coords
        dst_ds.SetProjection(base_raster.crs().authid())  # export coords to file
        band = dst_ds.GetRasterBand(1)
        band.SetUnitType("protection_value")
        if 0 != band.SetNoDataValue(0):
            feedback.pushWarning(f"Set No Data failed for {self.OUT_R}")
        if 0 != band.WriteArray(float32(dpv.reshape(H, W))):
            feedback.pushWarning(f"WriteArray failed for {self.OUT_R}")

        if context.willLoadLayerOnCompletion(output_raster_filename):
            # attach post processor
            display_name = NAME["dpv"]
            layer_details = context.LayerDetails(
                display_name, context.project(), display_name, QgsProcessingUtils.LayerHint.Raster
            )
            layer_details.groupName = NAME["layer_group"]
            layer_details.layerSortKey = 3
            context.addLayerToLoadOnCompletion(output_raster_filename, layer_details)
            context.layerToLoadOnCompletionDetails(output_raster_filename).setPostProcessor(
                run_alg_styler(
                    display_name,
                    layer_min_val=stats_min,
                    layer_max_val=stats_max,
                    layer_bands=1,
                )
            )

        write_log(feedback, name=self.name())
        return {self.OUT_R: output_raster_filename}

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return DownStreamProtectionValueMetric()

    def group(self):
        return self.tr(NAME["simm"])

    def groupId(self):
        return jolo(NAME["simm"])

    def name(self):
        return jolo(NAME["dpv"])

    def displayName(self):
        return self.tr(NAME["dpv"])

    def helpString(self):
        return self.shortHelpString()

    def shortHelpString(self):
        return self.tr(
            """This Metric mixes a user defined proteccion value raster with the fire spread history of each simulation (the Propagation Digraph). Using the fact that the value of a pixel should also include the values of downstream pixels (or succesors in its fire propagation tree); In the sense that protecting that pixel also protects where the fire would have gone if not protected<br>
            <a href="https://doi.org/10.1016/j.cor.2021.105252">https://doi.org/10.1016/j.cor.2021.105252</a><br>
            <b>To run:</b><br>
            1. Select a protection value raster 
                - Any number type works
                - NODATA is mapped to 0 value
                - In a relative sense, negative numbers mean you want them burned / unprotected
            2. First generate the Propagation Digraph Algorithm that generates the messages.pickle file <i>(skip showing them if they are too many simulations and periods)</i> by default along side the original messages.csv files
            3. Select the messages.pickle file
            <b>Advanced options:</b><br>
            - <b>Threads</b> Maximum number of threads to use simultaneously. Does not work on Windows! (use linux for serious parallelization)
            For retaining <i>protection value compatibility</i> use:
            - <b>No Burn Fill</b> Include original protection values where no fire was seen (default true)
            - <b>Scaling</b> Scale every pixel by burn count (default true); or all pixels by number of simulations (false)
            For <i>fraction of times pixels were burned</i> use the false options, even with burn probability as the protection value
            """
        )

    def icon(self):
        return QIcon(":/plugins/fireanalyticstoolbox/assets/dpv.svg")


def handle_post_processing(
    context, feedback, layer=None, layer_id=None, display_name="", style=None, group_name=NAME["layer_group"], **kwargs
) -> None:
    if not layer:
        layer = QgsProcessingUtils.mapLayerFromString(layer_id, context)
    if not layer_id:
        layer_id = layer.id()
    if display_name == "":
        display_name = layer.name()
    layer_details = context.LayerDetails(display_name, context.project(), display_name)
    context.addLayerToLoadOnCompletion(
        display_name,
        layer_details,
    )
    if context.willLoadLayerOnCompletion(layer_id):
        if style == "pseudocolor":
            context.layerToLoadOnCompletionDetails(layer_id).setPostProcessor(
                run_alg_styler(display_name, (0, 0, 255), (255, 0, 0), **kwargs)
            )
        elif style == "bin":
            context.layerToLoadOnCompletionDetails(layer_id).setPostProcessor(
                run_alg_styler_bin(display_name, (0, 0, 255), (255, 0, 0), **kwargs)
            )
        elif style == "propagation":
            context.layerToLoadOnCompletionDetails(layer_id).setPostProcessor(run_alg_styler_propagation())
