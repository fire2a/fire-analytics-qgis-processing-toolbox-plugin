# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FireToolbox
                                 A QGIS plugin
 A collection of fire insights related algorithms
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-04-16
        copyright            : (C) 2024 by Fernando Badilla Veliz - Fire2a.com
        email                : fbadilla@ing.uchile.cl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
__author__ = "Fernando Badilla Veliz - Fire2a.com"
__date__ = "2023-04-16"
__copyright__ = "(C) 2024 by Fernando Badilla Veliz - Fire2a.com"

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = "$Format:%H$"

from pathlib import Path

import processing
from fire2a.raster import get_geotransform
from qgis.core import (QgsProcessing, QgsProcessingAlgorithm, QgsProcessingParameterFileDestination,
                       QgsProcessingParameterRasterDestination, QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterString, QgsProcessingUtils)
from qgis.PyQt.QtCore import QCoreApplication
from qgis.PyQt.QtGui import QIcon

from .algorithm_utils import QgsProcessingParameterRasterDestinationAIIGrid, write_log


class MatchAIIGrid(QgsProcessingAlgorithm):

    IN_MODIFY = "modify"
    IN_MATCHTO = "matchto"
    IN_CLI_ARGS = "cli_args"
    OUT_MATCHED = "matched"

    def initAlgorithm(self, config):
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                name=self.IN_MODIFY,
                description=self.tr("Raster to modify"),
                defaultValue=[QgsProcessing.TypeRaster],
                optional=False,
            )
        )
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                name=self.IN_MATCHTO,
                description=self.tr("Raster to match to"),
                defaultValue=[QgsProcessing.TypeRaster],
                optional=False,
            )
        )

        self.addParameter(
            QgsProcessingParameterString(
                name=self.IN_CLI_ARGS,
                description=self.tr("CLI arguments"),
                defaultValue="",
                optional=True,
            )
        )

        self.addParameter(
            QgsProcessingParameterFileDestination(
                self.OUT_MATCHED,
                self.tr("Matched raster"),
                fileFilter="ASC files (*.asc)",
            )
        )

    def checkParameterValues(self, parameters, context):
        for raster in [self.IN_MODIFY, self.IN_MATCHTO]:
            layer = self.parameterAsRasterLayer(parameters, raster, context)
            if layer.publicSource() == "":
                return False, f"Can't find file! for {layer=} (Is saved to disk?)"
            if Path(layer.publicSource()).suffix != ".asc":
                return False, f"Only .asc files are supported! for {layer=} (Is saved to disk?)"
        return True, ""

    def processAlgorithm(self, parameters, context, feedback):
        """
        GT(0) x-coordinate of the upper-left corner of the upper-left pixel.
        GT(1) w-e pixel resolution / pixel width.
        GT(2) row rotation (typically zero).
        GT(3) y-coordinate of the upper-left corner of the upper-left pixel.
        GT(4) column rotation (typically zero).
        GT(5) n-s pixel resolution / pixel height (negative value for a north-up image).
        """
        cli_args = self.parameterAsString(parameters, self.IN_CLI_ARGS, context)
        feedback.pushInfo(f"{cli_args=}\n")

        modify = self.parameterAsRasterLayer(parameters, self.IN_MODIFY, context)
        feedback.pushInfo(f"{modify.publicSource()=}\n")
        match = self.parameterAsRasterLayer(parameters, self.IN_MATCHTO, context)
        feedback.pushInfo(f"{match.publicSource()=}\n {match.extent()=}\n")
        output = self.parameterAsOutputLayer(parameters, self.OUT_MATCHED, context)
        parent_dir = Path(output).parent
        feedback.pushInfo(f"{output=}\n")

        match_gt = get_geotransform(match.publicSource())
        # ulx, uly = match_gt[0], match_gt[3]
        # px_res, py_res = match_gt[1], match_gt[5]
        # row_rot, col_rot = match_gt[2], match_gt[4]

        # proj_win = f"-projwin1 {ulx} {uly} {ulx + px_res * match.width()} {uly + py_res * match.height()}"
        # feedback.pushInfo(f"{proj_win=}\n")
        extent = match.extent()
        proj_win = f"-projwin {extent.xMinimum()} {extent.yMaximum()} {extent.xMaximum()} {extent.yMinimum()}"
        feedback.pushInfo(f"{proj_win=}\n")

        clipped = processing.run(
            "gdal:translate",
            {
                "DATA_TYPE": 0,
                "EXTRA": cli_args,
                "INPUT": modify.publicSource(),
                "NODATA": None,
                "OPTIONS": "",
                "OUTPUT": str(parent_dir / "clipped.asc"),
                "OVERCRS": False,
                "PROJWIN": "f{extent.xMinimum()},{extent.xMaximum()},{extent.xMaximum()},{extent.yMinimum()}",
            },
            context=context,
            feedback=feedback,
            is_child_algorithm=True,
        )
        clipped = clipped.get("OUTPUT")
        if clipped is None:
            raise QgsProcessingException("Failed to clip raster")

        if cli_args:
            cli_args += " "
        cli_args += f"-a_gt {match_gt[0]} {match_gt[1]} {match_gt[2]} {match_gt[3]} {match_gt[4]} {match_gt[5]} -outsize {match.width()} {match.height()}"

        transformed = processing.run(
            "gdal:translate",
            {
                "COPY_SUBDATASETS": False,
                "DATA_TYPE": 0,
                "EXTRA": cli_args,
                "INPUT": clipped,
                "NODATA": None,
                "OPTIONS": "",
                "OUTPUT": output,
                "TARGET_CRS": None,
            },
            context=context,
            feedback=feedback,
            is_child_algorithm=True,
        )
        transformed = transformed.get("OUTPUT")
        if transformed is None:
            raise QgsProcessingException("Failed to clip raster")

        feedback.pushInfo(f"{transformed=}\n")

        layer = QgsProcessingUtils.mapLayerFromString(transformed, context)
        layer_details = context.LayerDetails(
            "Matched",
            context.project(),
            transformed,
            QgsProcessingUtils.LayerHint.Raster,
        )
        context.addLayerToLoadOnCompletion(transformed, layer_details)

        write_log(feedback, name=self.name())
        return {self.OUT_MATCHED: transformed}

    def name(self):
        """processing.run('provider:name',{..."""
        return "matchaiigrid"

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr("Match AII Grids")

    def group(self):
        return self.tr("Utils")

    def groupId(self):
        return "utils"

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return MatchAIIGrid()

    def helpUrl(self):
        return "https://fire2a.github.io/docs/qgis-toolbox"

    def shortDescription(self):
        return self.tr(
            """Simplifies using gdal translate to <b>clip extent, then resize and replace geotransform</b> to match an ascii raster into another<br><br>
            useful cli_args: -r {nearest,bilinear,cubic,cubicspline,lanczos,average,mode} (default nearest)<br><br>
            not implemented: dealing with CRSs or nodatas.
            """
        )

    def icon(self):
        return QIcon(":/plugins/fireanalyticstoolbox/assets/match_aii.svg")
