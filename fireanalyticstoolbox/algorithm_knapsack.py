# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ProcessingPluginClass
                                 A QGIS plugin
 Description of the p p
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-07-12
        copyright            : (C) 2024 by fdo
        email                : fbadilla@ing.uchile.cl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
__author__ = "fdo"
__date__ = "2024-03-01"
__copyright__ = "(C) 2024 by fdo"
__version__ = "$Format:%H$"


import itertools
from contextlib import redirect_stderr, redirect_stdout
from pathlib import Path
from tempfile import NamedTemporaryFile

import numpy as np
import processing
from osgeo import gdal
from pyomo import environ as pyo
from qgis.core import (QgsFeature, QgsFeatureRequest, QgsFeatureSink, QgsField, QgsFields, QgsProcessing,
                       QgsProcessingAlgorithm, QgsProcessingException, QgsProcessingParameterBoolean,
                       QgsProcessingParameterDefinition, QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterFeatureSource, QgsProcessingParameterField, QgsProcessingParameterMatrix,
                       QgsProcessingParameterMultipleLayers, QgsProcessingParameterNumber,
                       QgsProcessingParameterRasterLayer)
from qgis.PyQt.QtCore import QCoreApplication, QVariant
from qgis.PyQt.QtGui import QIcon
from scipy import stats
from toml import dump as toml_dump

from .algorithm_utils import (QgsProcessingParameterRasterDestinationGpkg, array2rasterInt16, get_output_raster_format,
                              get_raster_data, get_raster_info, get_raster_nodata, write_log)
from .decision_optimization.doop import FileLikeFeedback, pyomo_init_algorithm, pyomo_parse_results, pyomo_run_model


class PolygonKnapsackAlgorithm(QgsProcessingAlgorithm):
    """Algorithm that selects the most valuable polygons restriced to a total weight using a MIP solver"""

    IN_LAYER = "IN_LAYER"
    IN_VALUE = "VALUE"
    IN_WEIGHT = "WEIGHT"
    IN_RATIO = "RATIO"
    OUT_LAYER = "OUT_LAYER"
    GEOMETRY_CHECK_SKIP_INVALID = "GEOMETRY_CHECK_SKIP_INVALID"

    solver_exception_msg = ""

    def initAlgorithm(self, config):
        """The form reads a vector layer and two fields, one for the value and one for the weight; also configures the weight ratio and the solver"""

        # input layer
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                name=self.IN_LAYER,
                description=self.tr("Input Polygons Layer"),
                types=[QgsProcessing.TypeVectorPolygon],
            )
        )
        # value field
        self.addParameter(
            QgsProcessingParameterField(
                name=self.IN_VALUE,
                description=self.tr("Attribute table field name for VALUE (if blank 1's will be used)"),
                defaultValue="VALUE",
                parentLayerParameterName=self.IN_LAYER,
                type=QgsProcessingParameterField.Numeric,
                allowMultiple=False,
                optional=True,
                defaultToAllFields=False,
            )
        )
        # weight field
        self.addParameter(
            QgsProcessingParameterField(
                name=self.IN_WEIGHT,
                description=self.tr("Attribute table field name for WEIGHT (if blank polygon's area will be used)"),
                defaultValue="WEIGHT",
                parentLayerParameterName=self.IN_LAYER,
                type=QgsProcessingParameterField.Numeric,
                allowMultiple=False,
                optional=True,
                defaultToAllFields=False,
            )
        )
        # ratio double
        qppn = QgsProcessingParameterNumber(
            name=self.IN_RATIO,
            description=self.tr("Capacity ratio (1 = weight.sum)"),
            type=QgsProcessingParameterNumber.Double,
            defaultValue=0.069,
            optional=False,
            minValue=0.0,
            maxValue=1.0,
        )
        qppn.setMetadata({"widget_wrapper": {"decimals": 3}})
        self.addParameter(qppn)
        # output layer
        self.addParameter(QgsProcessingParameterFeatureSink(self.OUT_LAYER, self.tr("Polygon Knapsack Output Layer")))

        qppb = QgsProcessingParameterBoolean(
            name=self.GEOMETRY_CHECK_SKIP_INVALID,
            description=self.tr(
                "Set invalid geometry check to GeometrySkipInvalid (more options clicking the wrench on the input poly"
                " layer)"
            ),
            defaultValue=True,
            optional=True,
        )
        qppb.setFlags(qppb.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(qppb)
        pyomo_init_algorithm(self, config)

    def processAlgorithm(self, parameters, context, feedback):
        # setup ignore
        if self.parameterAsBool(parameters, self.GEOMETRY_CHECK_SKIP_INVALID, context):
            context.setInvalidGeometryCheck(QgsFeatureRequest.GeometrySkipInvalid)
            feedback.pushWarning("setInvalidGeometryCheck set to GeometrySkipInvalid")

        # report solver unavailability
        feedback.pushWarning(f"Solver unavailability:\n{self.solver_exception_msg}\n")

        layer = self.parameterAsSource(parameters, self.IN_LAYER, context)
        feedback.pushDebugInfo(
            f"{layer=}, {layer.fields()=}, {layer.wkbType()=}, {layer.sourceCrs()=}, {layer.featureCount()=}"
        )

        request_fields = []
        if value_fieldname := self.parameterAsString(parameters, self.IN_VALUE, context):
            request_fields += [value_fieldname]
        if weight_fieldname := self.parameterAsString(parameters, self.IN_WEIGHT, context):
            request_fields += [weight_fieldname]
        qfr = QgsFeatureRequest().setSubsetOfAttributes(request_fields, layer.fields())
        features = list(layer.getFeatures(qfr))
        feedback.pushWarning(
            f"Valid polygons: {len(features)}/{layer.featureCount()} {len(features)/layer.featureCount():.2%}\n"
        )

        if value_fieldname:
            value_data = [feat.attribute(value_fieldname) for feat in features]
        else:
            value_data = [1] * len(features)
            feedback.pushWarning("No value field, using 1's")
        value_data = np.array(value_data)

        if weight_fieldname:
            weight_data = [feat.attribute(weight_fieldname) for feat in features]
        else:
            weight_data = [feat.geometry().area() for feat in features]
            feedback.pushWarning("No weight field, using polygon areas")
        weight_data = np.array(weight_data)

        def unsafe_cast(x):
            try:
                return np.float32(x)
            except (TypeError, ValueError):
                return np.nan

        cast_it = np.vectorize(unsafe_cast)

        value_data = cast_it(value_data)
        weight_data = cast_it(weight_data)

        feedback.pushDebugInfo(
            f"{value_data.dtype=}, {value_data.shape=}, {value_data=}\n{weight_data.dtype=}, {weight_data.shape=},"
            f" {weight_data=}\n"
        )
        for vd in value_data:
            feedback.pushDebugInfo(f"{vd=}, {type(vd)=}")

        assert len(value_data) == len(weight_data)
        N = len(value_data)
        no_indexes = np.where(np.isnan(value_data) | np.isnan(weight_data))[0]
        feedback.pushWarning(
            f"discarded polygons (value or weight invalid): {len(no_indexes)}/{N} {len(no_indexes)/N:.2%}\n"
        )
        mask = np.ones(N, dtype=bool)
        mask[no_indexes] = False

        ratio = self.parameterAsDouble(parameters, self.IN_RATIO, context)
        weight_sum = weight_data[mask].sum()
        capacity = np.round(weight_sum * ratio)
        feedback.pushInfo(f"capacity bound: {ratio=}, {weight_sum=}, {capacity=}\n")

        # cplex hack
        # TODO : make pull request to pyomo to fix this
        if tmp := self.parameterAsString(parameters, "SOLVER", context):
            if tmp.startswith("cplex"):
                value_data = value_data.astype("float64")
                weight_data = weight_data.astype("float64")
                feedback.pushDebugInfo(f"cplex hack: changed dtypes {value_data.dtype=},{weight_data.dtype=}")

        model = do_knapsack(value_data[mask], weight_data[mask], capacity)
        results = pyomo_run_model(self, parameters, context, feedback, model)
        retval, solver_dic = pyomo_parse_results(results, feedback)

        if retval > 1:
            solver_dic.update({self.OUT_LAYER: None})
            return solver_dic

        # pyomo solution to squared numpy array
        masked_response = np.array([pyo.value(model.X[i], exception=False) for i in model.X])
        # -2 undecided
        masked_response[masked_response == None] = -2
        masked_response = masked_response.astype(np.int16)
        # -1 left out
        response = -np.ones(N, dtype=np.int16)
        response[mask] = masked_response

        feedback.pushDebugInfo(f"{response=}, {response.shape=}")
        assert N == len(response)

        undecided, skipped, not_selected, selected = np.histogram(response, bins=[-2, -1, 0, 1, 2])[0]
        feedback.pushInfo(
            f"Solution histogram:\n{selected=}\n{not_selected=}\n{skipped=} (invalid value or weight)\n{undecided=}\n"
        )

        fields = QgsFields()
        fields.append(QgsField(name="fid", type=QVariant.Int))  # , len=10))
        fields.append(QgsField(name="knapsack", type=QVariant.Int))  # , len=10))

        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUT_LAYER,
            context,
            fields,
            layer.wkbType(),
            layer.sourceCrs(),
        )
        feedback.pushDebugInfo(f"{sink=}, {dest_id=}")

        total = 100.0 / N
        for current, feature in enumerate(features):
            # Stop the algorithm if cancel button has been clicked
            if feedback.isCanceled():
                break
            # Prepare feature
            new_feature = QgsFeature(fields)
            fid = int(feature.id())
            res = int(response[current])
            new_feature.setId(fid)
            new_feature.setAttributes([fid, res])
            new_feature.setGeometry(feature.geometry())
            # feedback.pushDebugInfo(f"{new_feature.id()=}, {current=}, {response[current]=}")
            # Add a feature in the sink
            sink.addFeature(new_feature, QgsFeatureSink.FastInsert)
            # Update the progress bar
            feedback.setProgress(int(current * total))

        # if showing
        if context.willLoadLayerOnCompletion(dest_id):
            layer_details = context.layerToLoadOnCompletionDetails(dest_id)
            layer_details.groupName = "DecisionOptimizationGroup"
            layer_details.name = "KnapsackPolygons"
            # layer_details.layerSortKey = 2
            processing.run(
                "native:setlayerstyle",
                {
                    "INPUT": dest_id,
                    "STYLE": str(Path(__file__).parent / "decision_optimization" / "knapsack_polygon.qml"),
                },
                context=context,
                feedback=feedback,
                is_child_algorithm=True,
            )

        solver_dic.update({self.OUT_LAYER: dest_id})
        feedback.pushDebugInfo(f"{solver_dic=}")
        write_log(feedback, name=self.name())
        return solver_dic

    def name(self):
        """processing.run('provider:name',{..."""
        return "polygonknapsack"

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr("Polygon Knapsack")

    def group(self):
        return self.tr("Decision Optimization")

    def groupId(self):
        return "do"

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return PolygonKnapsackAlgorithm()

    def helpUrl(self):
        return "https://fire2a.github.io/docs/qgis-toolbox"

    def shortDescription(self):
        return self.tr(
            """Optimizes the classical knapsack problem using polygons with values and/or weights attributes, returns a polygon layer with the selected polygons."""
        )

    def icon(self):
        return QIcon(":/plugins/fireanalyticstoolbox/assets/firebreakmap.svg")


class RasterKnapsackAlgorithm(QgsProcessingAlgorithm):
    """Algorithm that takes selects the most valuable raster pixels restriced to a total weight using a MIP solver"""

    IN_VALUE = "VALUE"
    IN_WEIGHT = "WEIGHT"
    IN_RATIO = "RATIO"
    OUT_LAYER = "OUT_LAYER"

    NODATA = -32768  # -1?
    solver_exception_msg = ""

    def initAlgorithm(self, config):
        """The form reads two raster layers one for the value and one for the weight; also configures the weight ratio and the solver"""

        # value raster
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                name=self.IN_VALUE,
                description=self.tr("Values layer (if blank 1's will be used)"),
                defaultValue=[QgsProcessing.TypeRaster],
                optional=True,
            )
        )
        # weight raster
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                name=self.IN_WEIGHT,
                description=self.tr("Weights layer (if blank 1's will be used)"),
                defaultValue=[QgsProcessing.TypeRaster],
                optional=True,
            )
        )
        # ratio double
        qppn = QgsProcessingParameterNumber(
            name=self.IN_RATIO,
            description=self.tr("Capacity ratio (1 = weight.sum)"),
            type=QgsProcessingParameterNumber.Double,
            defaultValue=0.068,
            optional=False,
            minValue=0.0,
            maxValue=1.0,
        )
        qppn.setMetadata({"widget_wrapper": {"decimals": 3}})
        self.addParameter(qppn)
        # raster output
        # DestinationGpkg inherits from QgsProcessingParameterRasterDestination to set default gpkg output format
        self.addParameter(
            QgsProcessingParameterRasterDestinationGpkg(self.OUT_LAYER, self.tr("Raster Knapsack Output layer"))
        )
        pyomo_init_algorithm(self, config)

    def processAlgorithm(self, parameters, context, feedback):
        # feedback.pushCommandInfo(f"processAlgorithm START")
        # feedback.pushCommandInfo(f"parameters {parameters}")
        # feedback.pushCommandInfo(f"context args: {context.asQgisProcessArguments()}")

        # ?
        # feedback.reportError(f"context.logLevel(): {context.logLevel()}")
        # context.setLogLevel(context.logLevel()+1)

        # report solver unavailability
        feedback.pushInfo(f"Solver unavailability:\n{self.solver_exception_msg}\n")

        # get raster data
        value_layer = self.parameterAsRasterLayer(parameters, self.IN_VALUE, context)
        value_data = get_raster_data(value_layer)
        value_nodata = get_raster_nodata(value_layer, feedback)
        value_map_info = get_raster_info(value_layer)

        weight_layer = self.parameterAsRasterLayer(parameters, self.IN_WEIGHT, context)
        weight_data = get_raster_data(weight_layer)
        weight_nodata = get_raster_nodata(weight_layer, feedback)
        weight_map_info = get_raster_info(weight_layer)

        # raster(s) conditions
        if not value_layer and not weight_layer:
            feedback.reportError("No input layers, need at least one raster!")
            return {self.OUT_LAYER: None, "SOLVER_STATUS": None, "SOLVER_TERMINATION_CONDITION": None}
        elif value_layer and weight_layer:
            # TODO == -> math.isclose
            if not (
                value_map_info["width"] == weight_map_info["width"]
                and value_map_info["height"] == weight_map_info["height"]
                and value_map_info["cellsize_x"] == weight_map_info["cellsize_x"]
                and value_map_info["cellsize_y"] == weight_map_info["cellsize_y"]
            ):
                feedback.reportError("Layers must have the same width, height and cellsizes")
                return {self.OUT_LAYER: None, "SOLVER_STATUS": None, "SOLVER_TERMINATION_CONDITION": None}
            width, height, extent, crs, _, _ = value_map_info.values()
        elif value_layer and not weight_layer:
            width, height, extent, crs, _, _ = value_map_info.values()
            weight_data = np.ones(height * width)
        elif not value_layer and weight_layer:
            width, height, extent, crs, _, _ = weight_map_info.values()
            value_data = np.ones(height * width)

        # instance summary
        N = width * height

        feedback.pushInfo(
            f"width: {width}, height: {height}, N:{N}\n"
            f"extent: {extent}, crs: {crs}\n"
            "\n"
            f"value !=0: {np.any(value_data!=0)}\n"
            f"nodata: {value_nodata}\n"
            f"preview: {value_data}\n"
            f"stats: {stats.describe(value_data[value_data!=value_nodata])}\n"
            "\n"
            f"weight !=1: {np.any(weight_data!=1)}\n"
            f"nodata: {weight_nodata}\n"
            f"preview: {weight_data}\n"
            f"stats: {stats.describe(weight_data[weight_data!=weight_nodata])}\n"
        )
        if isinstance(value_nodata, list):
            feedback.pushError(f"value_nodata: {value_nodata} is list, not implemented!")
        if isinstance(weight_nodata, list):
            feedback.pushError(f"weight_nodata: {weight_nodata} is list, not implemented!")
        # nodata fest
        if value_nodata is None and weight_nodata is None:
            pass
        elif value_nodata is None and weight_nodata is not None:
            self.NODATA = weight_nodata
        elif value_nodata is not None and weight_nodata is None:
            self.NODATA = value_nodata
        elif value_nodata == weight_nodata:
            self.NODATA = value_nodata
        elif value_nodata != weight_nodata:
            feedback.pushWarning(f"Rasters have different nodata values: {value_nodata=}, {weight_nodata=}")
        feedback.pushDebugInfo(f"Using {self.NODATA=}\n")

        no_indexes = np.where(
            (value_data == value_nodata) | (weight_data == weight_nodata) | np.isnan(value_data) | np.isnan(weight_data)
        )[0]
        feedback.pushInfo(f"discarded pixels (no_indexes): {len(no_indexes)/N:.2%}\n")

        mask = np.ones(N, dtype=bool)
        mask[no_indexes] = False

        ratio = self.parameterAsDouble(parameters, self.IN_RATIO, context)
        weight_sum = weight_data[mask].sum()
        capacity = np.round(weight_sum * ratio)
        feedback.pushInfo(f"capacity bound: {ratio=}, {weight_sum=}, {capacity=}\n")

        # cplex hack
        # TODO : make pull request to pyomo to fix this
        if tmp := self.parameterAsString(parameters, "SOLVER", context):
            if tmp.startswith("cplex"):
                value_data = value_data.astype("float64")
                weight_data = weight_data.astype("float64")
                feedback.pushDebugInfo(f"cplex hack: changed dtypes {value_data.dtype=},{weight_data.dtype=}")

        model = do_knapsack(value_data[mask], weight_data[mask], capacity)
        results = pyomo_run_model(self, parameters, context, feedback, model, display_model=False)
        retval, solver_dic = pyomo_parse_results(results, feedback)

        if retval > 1:
            solver_dic.update({self.OUT_LAYER: None})
            return solver_dic

        # pyomo solution to squared numpy array
        masked_response = np.array([pyo.value(model.X[i], exception=False) for i in model.X])
        # -2 undecided
        masked_response[masked_response == None] = -2
        masked_response = masked_response.astype(np.int16)
        # -1 left out
        response = -np.ones(N, dtype=np.int16)
        response[mask] = masked_response

        feedback.pushDebugInfo(f"{response=}, {response.shape=}")
        assert N == len(response)

        undecided, nodata, not_selected, selected = np.histogram(response, bins=[-2, -1, 0, 1, 2])[0]
        feedback.pushInfo(
            f"Solution histogram:\n{selected=}\n{not_selected=}\n{nodata=} (invalid value or weight)\n{undecided=}\n"
        )
        response[response == -1] = self.NODATA
        response.resize(height, width)

        output_layer_filename = self.parameterAsOutputLayer(parameters, self.OUT_LAYER, context)
        outFormat = get_output_raster_format(output_layer_filename, feedback)

        array2rasterInt16(
            response,
            "knapsack",
            output_layer_filename,
            extent,
            crs,
            nodata=self.NODATA,
        )
        feedback.setProgress(100)
        feedback.setProgressText("Writing new raster to file ended, progress 100%")

        # if showing
        if context.willLoadLayerOnCompletion(output_layer_filename):
            layer_details = context.layerToLoadOnCompletionDetails(output_layer_filename)
            layer_details.groupName = "DecisionOptimizationGroup"
            layer_details.name = "KnapsackRaster"
            # layer_details.layerSortKey = 2
            processing.run(
                "native:setlayerstyle",
                {
                    "INPUT": output_layer_filename,
                    "STYLE": str(Path(__file__).parent / "decision_optimization" / "knapsack_raster.qml"),
                },
                context=context,
                feedback=feedback,
                is_child_algorithm=True,
            )
            feedback.pushDebugInfo(f"Showing layer {output_layer_filename}")

        solver_dic.update({self.OUT_LAYER: output_layer_filename})
        feedback.pushDebugInfo(f"{solver_dic=}")
        write_log(feedback, name=self.name())
        return solver_dic

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return "rasterknapsack"

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr("Raster Knapsack")

    def group(self):
        return self.tr("Decision Optimization")

    def groupId(self):
        return "do"

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return RasterKnapsackAlgorithm()

    def helpUrl(self):
        return "https://fire2a.github.io/docs/qgis-toolbox"

    def shortDescription(self):
        return self.tr(
            """Optimizes the classical knapsack problem using layers as values and/or weights, returns a layer with the selected pixels."""
        )

    def helpString(self):
        return self.shortHelpString()

    def icon(self):
        return QIcon(":/plugins/fireanalyticstoolbox/assets/firebreakmap.svg")

    def shortHelpString(self):
        return self.tr(
            """By selecting a Values layer and/or a Weights layer, and setting the bound on the total capacity, a layer that maximizes the sum of the values of the selected pixels is created.

            A new raster (default .gpkg) will show selected pixels in red and non-selected green (values 1, 0 and no-data=-1).

            The capacity constraint is set up by choosing a ratio (between 0 and 1), that multiplies the sum of all weights (except no-data). Hence 1 selects all pixels that aren't no-data in both layers.

            This raster knapsack problem is NP-hard, so a MIP solver engine is used to find "nearly" the optimal solution (**), because -often- is asymptotically hard to prove the optimal value. So a default gap of 0.5% and a timelimit of 5 minutes cuts off the solver run. The user can experiment with these parameters to trade-off between accuracy, speed and instance size(*). On Windows closing the blank terminal window will abort the run!

            By using Pyomo, several MIP solvers can be used: CBC, GLPK, Gurobi, CPLEX or Ipopt; If they're accessible through the system PATH, else the executable file can be selected by the user. Installation of solvers is up to the user.

            Although windows version is bundled with CBC unsigned binaries, so their users may face a "Windows protected your PC" warning, please avoid pressing the "Don't run" button, follow the "More info" link, scroll then press "Run anyway". Nevertheless windows cbc does not support multithreading, so ignore that warning (or switch to Linux).

            (*): Complexity can be reduced greatly by rescaling and/or rounding values into integers, or even better coarsing the raster resolution (see gdal translate resolution).
            (**): There are specialized knapsack algorithms that solve in polynomial time, but not for every data type combination; hence using a MIP solver is the most flexible approach.

            ----

            USE CASE:

            If you want to determine where to allocate fuel treatments throughout the landscape to protect a specific value that is affected by both the fire and the fuel treatments, use the following:

                - Values: Downstream Protection Value layer calculated with the respective value that you want to protect.

                - Weights: The layer, that contains the value that you want to protect and that is affected also by the fuel treatments (e.g., animal habitat).
            If you want to determine where to allocate fuel treatments through out the landscape to protect and specific value that is affected by both, the fire and the fuel treatments use: 
            """
        )


def do_knapsack(value_data, weight_data, capacity):
    """paste into processAlgorithm to be used in any KnapsackAlgorithm
    Returns:
        np.array: response with values 1 selected, 0 not selected, -1 for left out indexes, -2 for solver undecided
        length of response is equal to the length of value_data and weight_data
    """
    N = len(value_data)
    m = pyo.ConcreteModel()
    m.N = pyo.RangeSet(0, N - 1)
    m.Cap = pyo.Param(initialize=capacity)
    m.We = pyo.Param(m.N, within=pyo.Reals, initialize=weight_data)
    m.Va = pyo.Param(m.N, within=pyo.Reals, initialize=value_data)
    m.X = pyo.Var(m.N, within=pyo.Binary)
    obj_expr = pyo.sum_product(m.X, m.Va, index=m.N)
    m.obj = pyo.Objective(expr=obj_expr, sense=pyo.maximize)

    def capacity_rule(m):
        return pyo.sum_product(m.X, m.We, index=m.N) <= m.Cap

    m.capacity = pyo.Constraint(rule=capacity_rule)
    return m


class MultiObjectiveRasterKnapsackAlgorithm(QgsProcessingAlgorithm):
    """Selects the most valuable raster pixels restriced to a total capacity using a MIP solver. The valuation is done by a matrix of weights"""

    INPUT_RASTERS = "InputRasters"
    MATRIX = "Matrix"
    PLOTS = "Plots"
    RELAXEXCLUDENODATA = "RelaxExcludeNoData"
    matrix_headers = ["value_rescaling", "value_weight", "capacity_sense", "capacity_ratio"]
    matrix_headers_types = [str, float, str, float]

    OUT_LAYER = "OUT_LAYER"

    solver_exception_msg = ""

    def initAlgorithm(self, config):
        """The form reads two raster layers one for the value and one for the weight; also configures the weight ratio and the solver"""

        # values rasters
        self.addParameter(
            QgsProcessingParameterMultipleLayers(
                name=self.INPUT_RASTERS,
                description=self.tr("Input rasters"),
                layerType=QgsProcessing.TypeRaster,
                defaultValue=[QgsProcessing.TypeRaster],
                optional=False,
            )
        )

        # name: str, description: str = '', numberRows: int = 3, hasFixedNumberRows: bool = False, headers: Iterable[str] = [], defaultValue: Any = None, optional: bool = False
        self.addParameter(
            QgsProcessingParameterMatrix(
                name=self.MATRIX,
                description=self.tr("Raster Configuration Matrix (use same order than input rasters)"),
                headers=self.matrix_headers,
                optional=True,
            )
        )
        # raster output
        # DestinationGpkg inherits from QgsProcessingParameterRasterDestination to set default gpkg output format
        self.addParameter(
            QgsProcessingParameterRasterDestinationGpkg(self.OUT_LAYER, self.tr("Raster Knapsack Output layer"))
        )
        qppb = QgsProcessingParameterBoolean(
            name=self.PLOTS,
            description="Write debugging plots to the same directory as the output layer, includes: observations, scaled values, capacity violin plots & solution stats",
            defaultValue="True",
            optional=True,
        )
        qppb.setFlags(qppb.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(qppb)
        qppb2 = QgsProcessingParameterBoolean(
            name=self.RELAXEXCLUDENODATA,
            description="Relax excluding nodata values from any to all (layers containing nodata will exclude its pixel from the model)",
            defaultValue="False",
            optional=True,
        )
        qppb2.setFlags(qppb2.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(qppb2)
        pyomo_init_algorithm(self, config)

    def processAlgorithm(self, parameters, context, feedback):
        # feedback.pushCommandInfo(f"processAlgorithm START")
        # feedback.pushCommandInfo(f"parameters {parameters}")
        # feedback.pushCommandInfo(f"context args: {context.asQgisProcessArguments()}")

        # ?
        # feedback.reportError(f"context.logLevel(): {context.logLevel()}")
        # context.setLogLevel(context.logLevel()+1)

        # report solver unavailability
        feedback.pushInfo(f"Solver unavailability:\n{self.solver_exception_msg}\n")

        raster_list = self.parameterAsLayerList(parameters, self.INPUT_RASTERS, context)
        for r in raster_list:
            if not Path(r.publicSource()).is_file():
                feedback.reportError(f"Raster file not found: {r.publicSource()}")
                raise QgsProcessingException(f"Raster file not found: {r.publicSource()}")

        feedback.pushDebugInfo(f"Input rasters names: {[ r.name() for r in raster_list]}\n")

        config_toml = {r.publicSource(): {} for r in raster_list}
        args = {}
        for r in raster_list:
            if gt := gdal.Open(r.publicSource(), gdal.GA_ReadOnly).GetGeoTransform():
                args["--geotransform"] = str(gt)
                break
        for r in raster_list:
            if authid := r.crs().authid():
                args["--authid"] = authid
                break
        if "--authid" not in args:
            args["--authid"] = QgsProject.instance().crs().authid()
        if self.parameterAsBool(parameters, self.PLOTS, context):
            args["--plots"] = ""
        if self.parameterAsBool(parameters, self.RELAXEXCLUDENODATA, context):
            args["--exclude_nodata"] = "all"

        matrix = self.parameterAsMatrix(parameters, self.MATRIX, context)
        # feedback.pushDebugInfo(f"Matrix: {matrix=} {len(matrix)=} {type(matrix)=}")
        # ["scaling_strategy", "no_data_strategy", "fill_value", "weight"]
        mtx_len = len(matrix)
        row_len = len(self.matrix_headers)
        num_rows = mtx_len // row_len

        # recreate config.toml
        for i, fname in zip(range(num_rows), config_toml):
            row = matrix[i * row_len : (i + 1) * row_len]
            for j, (header, atype) in enumerate(zip(self.matrix_headers, self.matrix_headers_types)):
                if row[j] != QVariant() and row[j] != "":
                    try:
                        config_toml[fname][header] = atype(row[j])
                    except Exception as e:
                        msg = (
                            f"{e}\nError in Raster Configuration Matrix: {header=} at row {i+1} can't convert {row[j]} to {atype}",
                        )
                        feedback.reportError(msg)
                        raise QgsProcessingException(msg)
            # feedback.pushDebugInfo(f"{row=}")
            feedback.pushDebugInfo(f"{fname} : {config_toml[fname]}\n")

        if output_raster := self.parameterAsOutputLayer(parameters, self.OUT_LAYER, context):
            # feedback.pushDebugInfo(f"Output raster: {output_raster=} {type(output_raster)=}")
            args["--output_raster"] = output_raster

        # store config as a toml file in the same path as output_polygons
        config_file = NamedTemporaryFile(mode="w", suffix=".toml", dir=Path(output_raster).parent, delete=False)
        with open(config_file.name, "w") as toml_file:
            toml_dump(config_toml, toml_file)

        commands_list = ([k, v] for k, v in args.items())
        commands_list = list(itertools.chain.from_iterable(commands_list))
        commands_list = [cmd for cmd in commands_list if cmd != ""]
        commands_list = commands_list + [config_file.name]
        feedback.pushWarning(
            "fire2a-lib cli alternative:\npython -m fire2a.knapsack "
            + " ".join(commands_list)
            + '\nDepending on the terminal the geotransform might need quotes "(0,0,1,0,-1)" around it to be read correctly'
        )
        # fire2a-lib
        from fire2a.knapsack import get_model, post_solve, pre_solve

        std_feedback = FileLikeFeedback(feedback, True)
        err_feedback = FileLikeFeedback(feedback, False)
        with redirect_stdout(std_feedback), redirect_stderr(err_feedback):
            # pre
            instance, args2 = pre_solve(commands_list)
            # model
            model = get_model(**instance)
        # solve
        results = pyomo_run_model(self, parameters, context, feedback, model)
        instance["results"] = results
        # post
        retval, solver_dic = pyomo_parse_results(results, feedback)
        if retval > 1:
            solver_dic.update({self.OUT_LAYER: None})
            feedback.reportError("Error running solver")
            return solver_dic

        with redirect_stdout(std_feedback), redirect_stderr(err_feedback):
            if 0 != post_solve(model, args=args2, **instance):
                feedback.reportError("Error post processing solution")

        # if showing
        if context.willLoadLayerOnCompletion(output_raster):
            layer_details = context.layerToLoadOnCompletionDetails(output_raster)
            layer_details.groupName = "DecisionOptimizationGroup"
            layer_details.name = "MultiObjectiveKnapsackRaster"
            # layer_details.layerSortKey = 2
            processing.run(
                "native:setlayerstyle",
                {
                    "INPUT": output_raster,
                    "STYLE": str(Path(__file__).parent / "decision_optimization" / "knapsack_raster.qml"),
                },
                context=context,
                feedback=feedback,
                is_child_algorithm=True,
            )
            feedback.pushDebugInfo(f"Showing layer {output_raster}")

        if self.parameterAsBool(parameters, self.PLOTS, context):
            feedback.pushDebugInfo("Plots:")
            outpath = Path(output_raster).parent
            for afile in ["observations.png", "scaled.png", "scaled_weighted.png", "solution.png"]:
                if (apath := outpath / afile).is_file():
                    feedback.pushDebugInfo(apath.as_uri())
                    feedback.pushFormattedMessage(f'<img src="{str(apath)}">', apath.as_uri())
                    # feedback.pushCommandInfo('<img src="' + str(apath) + '">')
            feedback.pushWarning("Disable plots to speed up calculations")

        write_log(feedback, name=self.name())
        return {self.OUT_LAYER: output_raster, "CONFIG": config_file.name}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return "multirasterknapsack"

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr("Multi Objective Raster Knapsack")

    def group(self):
        return self.tr("Decision Optimization")

    def groupId(self):
        return "do"

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return MultiObjectiveRasterKnapsackAlgorithm()

    def helpUrl(self):
        return "https://fire2a.github.io/docs/qgis-toolbox"

    def shortDescription(self):
        return self.tr(
            """Optimizes a multi objective knapsack problem using layers as values and/or weights, returns a layer with the selected pixels."""
        )

    def helpString(self):
        return self.shortHelpString()

    def icon(self):
        return QIcon(":/plugins/fireanalyticstoolbox/assets/firebreakmap.svg")

    def shortHelpString(self):
        return self.tr(
            """<b>1.</b> Select a list of rasters to be used as values (to maximize or minimize) or weights (to be capacity constrained).
            (drag to reorder the rasters to match the matrix)

            <b>2.</b> Complete the matrix datasheet in the same order as 1.:
            <b>- value_rescaling</b>: minmax, onehot, standard, robust or pass for no rescaling.
                <a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMax.html">MinMax</a> is default if only a value_weight is provided.
                <a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html">OneHotEncoder</a> is for categorical data, e.g., fuel models.
                MinMax and OneHot outputs into [0,1] range, <a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html">Standard Scaler</a> (x - &mu;) / &sigma; and <a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.RobustScaler.html">Robust Scaler</a> (same without outliers) not
            <b>- value_weight</b>: Any real number, although 0 doesn't make sense, <i>negative values are for minimizing instead of maximizing</i>
            <b>- capacity_sense</b>, whether <i>at most or at least</i>, use any of: "&lt;=, &le;, le, ub" or "&gt;=, &ge;, ge, lb", respectively.
            <b>- capacity_ratio</b>: A real number, inside (-1,1). Internally it's multiplied by the <i>sum of all weights of that layer</i>. E.g., 0.5 selects (at most or at least) half of the pixels, if all weights (values of that raster) are equal.
            <b>3. [speed-up]</b> Stop visually debugging your calculations by disabling the plots option in Advanced Parameters (writing the plots can take a while).

            A new raster with selected, not selected and undecided pixels will be created. The undecided pixels means the solver failed to terminate fully; modifying solver options can mitigate this issue.

            The classical knapsack problem is NP-hard, so a MIP solver engine is used to find "nearly" the optimal solution (**), because -often- is asymptotically hard to prove the optimal value. So a default gap of 0.5% and a timelimit of 5 minutes cuts off the solver run. The user can experiment with these parameters to trade-off between accuracy, speed and instance size(*). On Windows closing the blank terminal window will abort the run!

            By using Pyomo, several MIP solvers can be used: CBC, GLPK, Gurobi, CPLEX or Ipopt; If they're accessible through the system PATH, else the executable file can be selected by the user. Installation of solvers is up to the user.

            Although windows version is bundled with CBC unsigned binaries, so their users may face a "Windows protected your PC" warning, please avoid pressing the "Don't run" button, follow the "More info" link, scroll then press "Run anyway". Nevertheless windows cbc does not support multithreading, so ignore that warning (or switch to Linux).

            (*): Complexity can be reduced greatly by rescaling and/or rounding values into integers, or even better coarsing the raster resolution (see gdal translate resolution).
            (**): There are specialized knapsack algorithms that solve in polynomial time, but not for every data type combination; hence using a MIP solver is the most flexible approach.

            """
        )
