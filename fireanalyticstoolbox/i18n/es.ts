<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE TS>
<TS version="2.1" language="es">
<context>
    <name>BaseContext</name>
    <message>
        <location filename="../algorithm_deprecated.py" line="82"/>
        <source>Base raster (normally fuel or elevation) to get the geotransform</source>
        <translation type="obsolete">Raster base para posicionar el resultado (normalmente fuels o elevacion)</translation>
    </message>
</context>
<context>
    <name>BetweennessCentralityMetric</name>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1527"/>
        <source>Use default sampling ratio</source>
        <translation>Usar la ratio de sampleo por defecto</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1535"/>
        <source>K samples to estimate betweenness.
 Not set and disabled default sampling checkbox means all nodes are used: very slow!
 Trade-off between accuracy and running time.</source>
        <translation>K muestras para estimar la centralidad de intermediación.
	No fijado y deshabilitada la casilla de muestreo por defecto significa que se usan todos los nodos: ¡muy lento!
	Es un dilema entre precisión y tiempo de ejecución.</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1550"/>
        <source>Random number generator seed for sampling. Used if K is not set.</source>
        <translation>Semilla del generador de números aleatorios para el muestreo. Se usa si K no está configurado.</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1506"/>
        <source>Base raster (normally fuel or elevation) to get the geotransform</source>
        <comment>BaseContext</comment>
        <translation>Raster base para posicionar el resultado (normalmente fuels o elevacion)</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1570"/>
        <source>Output raster</source>
        <comment>BaseContext</comment>
        <translation>Raster de salida</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1514"/>
        <source>Pickled messages (normally generated by the Propagation Digraph Algorithm results/Messages/messages.pickle)</source>
        <translation>Mensajes en formato pickle (normalmente generados por el algoritmo Propagation Digraph en results/Messages/messages.pickle)</translation>
    </message>
</context>
<context>
    <name>BurnProbabilityMetric</name>
    <message>
	<location filename="../algorithm_postsimulation.py" line="1340"/>
	<source>Burn probabilty raster is the mean of all simulations&lt;br&gt;
	    It&apos;s the same as using the &apos;Fire Scar&apos; algorithm, skipping output for scars and polygons, leaving only the &apos;Burn Probability&apos; output enabled&lt;br&gt;
	    From a simulation results directory, select the &apos;Grids&apos; directory and choose any of the &apos;ForestGrid&apos; files
	    </source>
	<translation>El raster de probabilidad de quema (BP) es la media de todas las simulaciones&lt;br&gt;
		    Es lo mismo que usar el algoritmo 'Fire Scar', omitiendo la salida de cicatrices y polígonos, dejando solo la salida de 'Burn Probability' habilitada&lt;br&gt;
	    </translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1272"/>
        <source>burn probability</source>
        <translation>probabilidad de quema</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1251"/>
        <source>Base raster (normally fuel or elevation) to get the geotransform</source>
        <comment>BaseContext</comment>
        <translation>Raster base para posicionar el resultado (normalmente fuels o elevacion)</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1272"/>
        <source>Output raster</source>
        <comment>BaseContext</comment>
        <translation>Raster de salida</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1259"/>
        <source>Sample Fire Scar file (normally firesim_yymmdd_HHMMSS/results/Grids/Grids[0-9]*/ForestGrid[0-9]*.csv)</source>
        <translation>Archivo de muestra de cicatriz de fuego (normalmente firesim_yymmdd_HHMMSS/results/Grids/Grids[0-9]*/ForestGrid[0-9]*.csv)</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1302"/>
        <source>BurnProbability</source>
        <translation>ProbabilidadDeQuema</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1308"/>
        <source>Burn Probability</source>
        <translation>Probabilidad de quema</translation>
    </message>
</context>
<context>
    <name>ClusterizeAlgorithm</name>
    <message>
        <location filename="../algorithm_clusterize.py" line="88"/>
        <source>to clusterize</source>
        <translation>para agrupar</translation>
    </message>
    <message>
        <location filename="../algorithm_clusterize.py" line="99"/>
        <source>Raster Configuration Matrix (use same order than input rasters)</source>
        <translation>Matriz de configuración de raster (usar el mismo orden que los rasters de entrada)</translation>
    </message>
    <message>
        <location filename="../algorithm_clusterize.py" line="108"/>
        <source>Distance threshold [adjusted observations]</source>
        <translation>Umbral de distancia [observaciones ajustadas]</translation>
    </message>
    <message>
        <location filename="../algorithm_clusterize.py" line="122"/>
        <source>Total clusters</source>
        <translation>Total de grupos</translation>
    </message>
    <message>
        <location filename="../algorithm_clusterize.py" line="134"/>
        <source>Minimum surface [pixels]</source>
        <translation>Superficie mínima [píxeles]</translation>
    </message>
    <message>
        <location filename="../algorithm_clusterize.py" line="88"/>
        <source>Input rasters</source>
        <translation>Rasters de entrada</translation>
    </message>
    <message>
        <location filename="../algorithm_clusterize.py" line="183"/>
        <source>Output raster</source>
        <translation>Raster de salida</translation>
    </message>
    <message>
        <location filename="../algorithm_clusterize.py" line="190"/>
        <source>Output polygons</source>
        <translation>Polígonos de salida</translation>
    </message>
</context>
<context>
    <name>DownStreamProtectionValueMetric</name>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1724"/>
        <source>Protection Value Raster (get values &amp; geotransform)</source>
        <translation>Raster de valor de protección (usa valores y geotransformación)</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1755"/>
        <source>Maximum number of threads to use simultaneously</source>
        <translation>Número máximo de hilos a usar simultáneamente</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1943"/>
        <source>This Metric mixes a user defined proteccion value raster with the fire spread history of each simulation (the Propagation Digraph). Using the fact that the value of a pixel should also include the values of downstream pixels (or succesors in its fire propagation tree); In the sense that protecting that pixel also protects where the fire would have gone if not protected&lt;br&gt;
	    &lt;a href=&quot;https://doi.org/10.1016/j.cor.2021.105252&quot;&gt;https://doi.org/10.1016/j.cor.2021.105252&lt;/a&gt;&lt;br&gt;
	    &lt;b&gt;To run:&lt;/b&gt;&lt;br&gt;
	    1. Select a protection value raster 
		- Any number type works
		- NODATA is mapped to 0 value
		- In a relative sense, negative numbers mean you want them burned / unprotected
	    2. First generate the Propagation Digraph Algorithm that generates the messages.pickle file &lt;i&gt;(skip showing them if they are too many simulations and periods)&lt;/i&gt; by default along side the original messages.csv files
	    3. Select the messages.pickle file
	    &lt;b&gt;Advanced options:&lt;/b&gt;&lt;br&gt;
	    - &lt;b&gt;Threads&lt;/b&gt; Maximum number of threads to use simultaneously. Does not work on Windows! (use linux for serious parallelization)
	    For retaining &lt;i&gt;protection value compatibility&lt;/i&gt; use:
	    - &lt;b&gt;No Burn Fill&lt;/b&gt; Include original protection values where no fire was seen (default true)
	    - &lt;b&gt;Scaling&lt;/b&gt; Scale every pixel by burn count (default true); or all pixels by number of simulations (false)
	    For &lt;i&gt;fraction of times pixels were burned&lt;/i&gt; use the false options, even with burn probability as the protection value
	    </source>
        <translation type="finished">Esta métrica mezcla un raster de valor de protección definido por el usuario con la historia de propagación del fuego de cada simulación (el gráfico de propagación). Usando el hecho de que el valor de un píxel también debería incluir los valores de los píxeles aguas abajo (o sucesores en su árbol de propagación del fuego); En el sentido de que proteger ese píxel también protege donde el fuego habría ido si no se hubiera protegido&lt;br&gt;
	    &lt;a href=&quot;https://doi.org/10.1016/j.cor.2021.105252&quot;&gt;https://doi.org/10.1016/j.cor.2021.105252&lt;/a&gt;&lt;br&gt;
	    &lt;b&gt;Para ejecutar:&lt;/b&gt;&lt;br&gt;
	    1. Selecciona un raster de valor de protección 
		- Cualquier tipo numérico funciona
		- NODATA se mapea a valor 0
		- En un sentido relativo, números negativos significan que quieres que se quemen / no protegidos
	    2. Primero genera el algoritmo del gráfico de propagación que genera el archivo messages.pickle &lt;i&gt;(omitir mostrarlos si son demasiadas simulaciones y períodos)&lt;/i&gt; por defecto junto a los archivos messages.csv originales
	    3. Selecciona el archivo messages.pickle
	    &lt;b&gt;Opciones avanzadas:&lt;/b&gt;&lt;br&gt;
	    - &lt;b&gt;Hilos&lt;/b&gt; Número máximo de hilos a usar simultáneamente. ¡No funciona en Windows! (usa linux para una paralelización seria)
	    Para mantener la compatibilidad del &lt;i&gt;valor de protección&lt;/i&gt; usa:
	    - &lt;b&gt;Relleno sin quemar&lt;/b&gt; Incluir valores originales de protección donde no se vio fuego (predeterminado verdadero)
	    - &lt;b&gt;Escalado&lt;/b&gt; Escalar cada píxel por cuenta de quemaduras (predeterminado verdadero); o todos los píxeles por número de simulaciones (falso)
		Para usar la &lt;i&gt;fracción de veces que los píxeles fueron quemados&lt;/i&gt;, usa las opciones falsas, incluso con probabilidad de quemadura como valor de protección</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1745"/>
        <source>Output raster</source>
        <comment>BaseContext</comment>
        <translation>Raster de salida</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1732"/>
        <source>Pickled messages (normally generated by the Propagation Digraph Algorithm results/Messages/messages.pickle)</source>
        <translation>Mensajes en formato pickle (normalmente generados por el algoritmo Grafo dirigido de propagación en results/Messages/messages.pickle)</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1766"/>
        <source>Include original protection values where no fire was seen (default true)</source>
        <translation>Incluir los valores de protección originales donde no fue visto fuego (predeterminado verdadero)</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1774"/>
        <source>Scale every pixel by burn count (default true); or all pixels by number of simulations (false)</source>
        <translation>Escalar cada píxel por cantidad de incendios vistos (predeterminado verdadero); o todos los píxeles por número de simulaciones (falso)</translation>
    </message>
</context>
<context>
    <name>FileLikeFeedback</name>
    <message>
	<location filename="../algorithm_clusterize.py" line="330"/>
	<source>Polygonize Multiple Rasters</source>
	<translation>Polygonizar múltiples rasters</translation>
    </message>
    <message>
	<location filename="../algorithm_clusterize.py" line="333"/>
	<source>Utils</source>
	<translation>Utilidades</translation>
    </message>
    <message>
	<location filename="../algorithm_clusterize.py" line="351"/>
	<source> &lt;h1&gt; Automatic clustering of different rasters &lt;/h1&gt;
	&lt;h2&gt; Overview &lt;/h2&gt;
	A scikit-learn pipeline that:
	1. Handles nodata with &lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.impute.SimpleImputer.html&quot;&gt;SimpleImputer&lt;/a&gt;
	2. Scales data with &lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html&quot;&gt;StandardScaler&lt;/a&gt;, &lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.RobustScaler.html&quot;&gt;RobustScaler&lt;/a&gt; which removes outliers or &lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html&quot;&gt;OneHotEncoder&lt;/a&gt; for categorical data like fuel models.
	3. Rescales all observations to [0, 1], then multiplies a prioritization (weight) to each raster.
	4. Clusterizes the map using the &lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.cluster.AgglomerativeClustering.html&quot;&gt;Agglomerative&lt;/a&gt; clustering algorithm.
	&lt;h2&gt; Usage &lt;/h2&gt;
	1. Select the rasters: notice you can drag &amp; drop to &lt;i&gt;reorder&lt;/i&gt; them.
	2. Optionally fill the matrix &lt;i&gt;in the same order&lt;/i&gt; than the selected rasters, with
	- scaling_strategy = [&quot;standard&quot;, &quot;robust&quot;, &quot;onehot&quot;] (default is &quot;standard&quot;)
	- no_data_strategy = [&quot;mean&quot;, &quot;median&quot;, &quot;most_frequent&quot;, &quot;constant&quot;] (default is &quot;mean&quot;)
	- fill_value = any number (only for &quot;constant&quot; no_data_strategy) (default is 0)
	- weight = any number (default is 1)
	&lt;b&gt;Categorical rasters (like fuel models) should use &quot;onehot&quot; and &quot;most_frequent&quot;&lt;/b&gt;
	&lt;br&gt;
	3. Experiment with the distance threshold until you get the desired number of clusters. Less distance (until 0) yields more clusters and processing time.
	4. Fine tune the output, ensuring clusters have a minimum number of pixels using the advanced parameter -that invokes GDAL&apos;s: &lt;a href=&quot;https://gdal.org/en/latest/programs/gdal_sieve.html#gdal-sieve&quot;&gt;gdal_sieve&lt;/a&gt;
	5. Outputs: The output polygon layer has the attribute &apos;number of pixels&apos;. The raster layer can be skipped.
	6. Data debug: There&apos;s an additional option to raise a (mat)plot(lib) window with original &amp; rescaled data distributions, clustering sizes history &amp; histogram labels. Available outside QGIS, by executing the shown command adding the &apos;--plots&apos; flag in the terminal (OSGeo4WShell).

	&lt;br&gt;
	&lt;i&gt;Both agglomerative and sieve connectivity is done with 4 neighbors because the fire simulator can cross diagonals&lt;i/&gt;

	In depth instructions can be found &lt;a href=&quot;https://fire2a.github.io/fire2a-lib/fire2a/agglomerative_clustering.html&quot;&gt;here&lt;/a&gt;
	</source>
	<translation>&lt;h1&gt; Agrupación automática de diferentes rasters &lt;/h1&gt;
	&lt;h2&gt; Descripción general &lt;/h2&gt;
	Una tubería de scikit-learn que:
	1. Maneja nodata con &lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.impute.SimpleImputer.html&quot;&gt;SimpleImputer&lt;/a&gt;
	2. Escala los datos con &lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html&quot;&gt;StandardScaler&lt;/a&gt;, &lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.RobustScaler.html&quot;&gt;RobustScaler&lt;/a&gt; que elimina valores atípicos o &lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html&quot;&gt;OneHotEncoder&lt;/a&gt; para datos categóricos como modelos de combustible.
	3. Reescala todas las observaciones a [0, 1], luego multiplica una priorización (peso) a cada raster.
	4. Agrupa el mapa usando el algoritmo de agrupamiento &lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.cluster.AgglomerativeClustering.html&quot;&gt;Agglomerative&lt;/a&gt;.
	&lt;h2&gt; Uso &lt;/h2&gt;
	1. Selecciona los rasters: nota que puedes arrastrar y soltar para &lt;i&gt;reordenarlos&lt;/i&gt;.
	2. Opcionalmente completa la matriz &lt;i&gt;en el mismo orden&lt;/i&gt; que los rasters seleccionados, con
	- scaling_strategy = [&quot;standard&quot;, &quot;robust&quot;, &quot;onehot&quot;] (predeterminado es &quot;standard&quot;)
	- no_data_strategy = [&quot;mean&quot;, &quot;median&quot;, &quot;most_frequent&quot;, &quot;constant&quot;] (predeterminado es &quot;mean&quot;)
	- fill_value = cualquier número (solo para &quot;constant&quot; no_data_strategy) (predeterminado es 0)
	- weight = cualquier número (predeterminado
	</translation>
    </message>
    <message>
        <location filename="../decision_optimization/doop.py" line="224"/>
        <source>Display the pyomo model in the console (disabled for rasters, can easily clog &amp; crash QGIS, use for debugging small models only!)</source>
        <translation>Mostrar el modelo pyomo en la consola (deshabilitado para rasters, porque puede obstruir y bloquear QGIS fácilmente, ¡usar solo para depurar modelos pequeños!)</translation>
    </message>
    <message>
        <location filename="../decision_optimization/doop.py" line="238"/>
        <source>LOCAL SOLVER</source>
        <translation>SOLVER LOCAL</translation>
    </message>
    <message>
        <location filename="../decision_optimization/doop.py" line="238"/>
        <source>Name: recommended options string [and executable STATUS]</source>
        <translation>Nombre: cadena (de texto) de opciones recomendadas [y ESTADO del ejecutable]</translation>
    </message>
    <message>
        <location filename="../decision_optimization/doop.py" line="257"/>
        <source>Override options_string (type a single space &apos; &apos; to not send any options to the solver)</source>
        <translation>Reemplazar cadena (de texto) de opciones (escribe un único espacio ' ' para no enviar ninguna opción al solver)</translation>
    </message>
    <message>
        <location filename="../decision_optimization/doop.py" line="266"/>
        <source>Set solver executable file [required if status is &apos;MUST SET EXECUTABLE&apos;]</source>
        <translation>Fijar archivo ejecutable del solver [requerido si el estado es 'MUST SET EXECUTABLE']</translation>
    </message>
    <message>
        <location filename="../decision_optimization/doop.py" line="276"/>
        <source>NEOS CLOUD SOLVER</source>
        <translation>SOLVER NEOS CLOUD</translation>
    </message>
    <message>
        <location filename="../decision_optimization/doop.py" line="276"/>
        <source>(not available for Pyomo+MsWindows)</source>
        <translation>(no disponible para Pyomo+MsWindows)</translation>
    </message>
    <message>
        <location filename="../decision_optimization/doop.py" line="276"/>
        <source>Registered email (visit https://neos-guide.org/)</source>
        <translation>Correo electrónico registrado (visita https://neos-guide.org/)</translation>
    </message>
    <message>
        <location filename="../decision_optimization/doop.py" line="289"/>
        <source>Solver name</source>
        <translation>Nombre del solver</translation>
    </message>
    <message>
        <location filename="../decision_optimization/doop.py" line="305"/>
        <source>Custom options string</source>
        <translation>Cadena (de texto) de opciones personalizada</translation>
    </message>
</context>
<context>
    <name>FireSimulatorAlgorithm</name>
    <message>
        <location filename="../algorithm_simulator.py" line="306"/>
        <source>
Firebreaks raster (1=firebreak)</source>
        <translation>Raster de cortafuegos (1=cortafuego)</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="329"/>
        <source>Generation mode</source>
        <translation>Modo de generación</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="761"/>
        <source>Single weather file scenario requires a file!</source>
        <translation>Un escenario de meteorológico único requiere un archivo!</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="775"/>
        <source>Multiple weathers requires a directory with Weather[0-9]*.csv files!</source>
        <translation>Múltiples escenarios de meteorológico requieren un directorio con archivos numerados Weather[0-9]*.csv!</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="971"/>
        <source>Cell2 Fire Simulator</source>
        <translation>Simulador de incendio por celdas</translation>
    </message>
    <message>
	<location filename="../algorithm_simulator.py" line="996"/>
	<source>
	    See documentation:
	    &lt;a href=https://fire2a.github.io/docs/qgis-toolbox/algo_simulator.html&gt;This dialog&lt;/a&gt;
	    &lt;a href=https://fire2a.github.io/docs/Cell2FireW&gt;Cell2FireW&lt;/a&gt;
	    &lt;font color=&quot;red&quot;&gt;Warning: GeoTiff(.tif) support (in development) limited to only reading the fuels layer!&lt;/font&gt; If planning to use more layers, transform them to AIIGrid(.asc) format!
	    &lt;font color=&quot;orange&quot;&gt;Warning: Kitral cbh and cbd rasters must use nodata -9999&lt;/font&gt;
	    </source>
	<translation>
	    Ver documentación:
	    &lt;a href=https://fire2a.github.io/docs/qgis-toolbox/algo_simulator.html&gt;Este diálogo&lt;/a&gt;
	    &lt;a href=https://fire2a.github.io/docs/Cell2FireW&gt;Cell2FireW&lt;/a&gt;
	    &lt;font color=&quot;red&quot;&gt;Advertencia: Soporte para GeoTiff(.tif) (en desarrollo) limitado a solo leer la capa de combustibles!&lt;/font&gt; Si planeas usar más capas, ¡transformalas al formato AIIGrid(.asc)!
	    &lt;font color=&quot;orange&quot;&gt;Advertencia: Los rasters Kitral cbh y cbd deben usar nodata -9999&lt;/font&gt;
	    </translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="218"/>
        <source>LANDSCAPE SECTION</source>
        <translation>SECCIÓN DEL PAISAJE</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="218"/>
        <source>Surface fuel model</source>
        <translation>Modelo de combustible superficial</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="238"/>
        <source>Style (paint) fuel raster with selected surface fuel model (native:setlayerstyle)</source>
        <translation>Dar estilo (pintar) raster de combustible con el modelo de combustible superficial seleccionado (native:setlayerstyle)</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="298"/>
        <source>Enable Crown Fire behavior</source>
        <translation>Habilitar comportamiento de fuego de copa</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="315"/>
        <source>IGNITION SECTION</source>
        <translation>SECCIÓN DE IGNICIÓN</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="315"/>
        <source>Number of simulations</source>
        <translation>Número de simulaciones</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="346"/>
        <source>Single point vector layer (requires generation mode 2)</source>
        <translation>Capa vectorial con un punto (requiere modo de generación 2)</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="359"/>
        <source>Radius around single point layer (requires generation mode 2)</source>
        <translation>Radio alrededor de la capa con un punto (requiere modo de generación 2)</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="371"/>
        <source>WEATHER SECTION</source>
        <translation>SECCIÓN METEOROLÓGICA</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="371"/>
        <source>source mode</source>
        <translation>modo de origen</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="381"/>
        <source>Single weather file scenario (requires source 0)</source>
        <translation>Escenario de un único archivo meteorológico (requiere origen 0)</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="392"/>
        <source>From multiple weathers in a directory (requires source 1)</source>
        <translation>De múltiples escenarios de meteorológicos en un directorio (requiere origen 1)</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="403"/>
        <source>Foliar Moisture Content [40%...200%] (requires Crown fire; Scott &amp; Burgan or Kitral Fuel Model)</source>
        <translation>Contenido de humedad foliar [40%...200%] (requiere fuego de copa; Modelo de Combustible Scott &amp; Burgan o Kitral)</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="416"/>
        <source>Live &amp; Dead Fuel Moisture Content Scenario [1=dry..4=moist] (requires Scott &amp; Burgan Fuel Model)</source>
        <translation>Contenido de humedad de combustible vivo y muerto [1=seco..4=húmedo] (requiere Modelo de Combustible Scott &amp; Burgan)</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="430"/>
        <source>RUN CONFIGURATION</source>
        <translation>CONFIGURACIÓN DE EJECUCIÓN</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="430"/>
        <source>simulation cpu threads (proportional to overall load to the computer by controlling number of simultaneous simulations)</source>
        <translation>hilos de CPU para simular (es proporcional a la carga sobre el ordenador al controlar el número de simulaciones simultáneas)</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="450"/>
        <source>Seed for the random number generator</source>
        <translation>Semilla para el generador de números aleatorios</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="462"/>
        <source>OUTPUTS SECTION</source>
        <translation>SECCIÓN DE SALIDAS</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="462"/>
        <source>options (click &apos;...&apos; button on the right)</source>
        <translation>opciones (haz clic en el botón '...' a la derecha)</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="481"/>
        <source>Override instance directory to &apos;$(Project Home)/firesim_yymmdd_HHMMSS&apos; (project must be open and saved locally)</source>
        <translation>Reemplazar directorio de instancia a '$(Project Home)/firesim_yymmdd_HHMMSS' (el proyecto debe estar abierto y guardado localmente)</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="492"/>
        <source>Instance directory (must be empty)</source>
        <translation>Directorio de instancia (debe estar vacío)</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="501"/>
        <source>Override results directory to &apos;$(instance directory)/results&apos;</source>
        <translation>Reemplazar directorio de resultados a '$(directorio de instancia)/resultados'</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="509"/>
        <source>Results directory (must be empty)</source>
        <translation>Directorio de resultados (debe estar vacío)</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="519"/>
        <source>Append additional command-line parameters (i.e., &apos;--verbose&apos;, use with caution!)</source>
        <translation>Agregar parámetros adicionales a la línea de comandos (por ejemplo, '--verbose', ¡usar con precaución!)</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="526"/>
        <source>(dry run) Don&apos;t simulate! Build instance folder, print the command to run, stop!</source>
        <translation>(dry run) ¡No simula! Construir la carpeta de instancia, imprimir el comando a ejecutar, ¡detener!</translation>
    </message>
    <message>
        <location filename="../algorithm_simulator.py" line="1000"/>
        <source>
            See documentation:
            &lt;a href=https://fire2a.github.io/docs/qgis-toolbox/algo_simulator.html&gt;This dialog&lt;/a&gt;
            &lt;a href=https://fire2a.github.io/docs/Cell2FireW&gt;Cell2FireW&lt;/a&gt;
            &lt;font color=&quot;red&quot;&gt;Warning: GeoTiff(.tif) support (in development) limited to only reading the fuels layer!&lt;/font&gt; If planning to use more layers, transform them to AIIGrid(.asc) format!
            &lt;font color=&quot;orange&quot;&gt;Warning: Kitral cbh and cbd rasters must use nodata -9999&lt;/font&gt;
            </source>
	<translation>
	    Ver documentación:
	    &lt;a href=https://fire2a.github.io/docs/qgis-toolbox/algo_simulator.html&gt;Este diálogo&lt;/a&gt;
	    &lt;a href=https://fire2a.github.io/docs/Cell2FireW&gt;Cell2FireW&lt;/a&gt;
	    &lt;font color=&quot;red&quot;&gt;Advertencia: Soporte para GeoTiff(.tif) (en desarrollo) limitado a solo leer la capa de combustibles!&lt;/font&gt; Si planeas usar más capas, ¡transformalas al formato AIIGrid(.asc)!
	    &lt;font color=&quot;orange&quot;&gt;Advertencia: Los rasters Kitral cbh y cbd deben usar nodata -9999&lt;/font&gt;
	    </translation>
    </message>
</context>
<context>
    <name>FireToolboxAlgorithm</name>
    <message>
        <location filename="../fireanalyticstoolbox_algorithm.py" line="67"/>
        <source>Input layer</source>
        <translation>Capa de entrada</translation>
    </message>
    <message>
        <location filename="../fireanalyticstoolbox_algorithm.py" line="76"/>
        <source>Output layer</source>
        <translation>Capa de salida</translation>
    </message>
</context>
<context>
    <name>FireToolboxProvider</name>
    <message>
        <location filename="../fireanalyticstoolbox_provider.py" line="113"/>
        <source>Fire Analytics</source>
        <translation>Analíticas de incendios</translation>
    </message>
</context>
<context>
    <name>IgnitionPointsFromLogFileSIMPP</name>
    <message>
        <location filename="../algorithm_deprecated.py" line="100"/>
        <source>Output ignition point(s) layer</source>
        <translation>Capa de salida con punto(s) de ignición</translation>
    </message>
    <message>
        <location filename="../algorithm_deprecated.py" line="189"/>
        <source>zdeprecated</source>
        <translation>zdeprecado</translation>
    </message>
    <message>
        <location filename="../algorithm_deprecated.py" line="198"/>
        <source>Ignition Points From LogFile</source>
        <translation>Puntos de ignición desde archivo de registro LogFile.txt</translation>
    </message>
    <message>
        <location filename="../algorithm_deprecated.py" line="82"/>
        <source>Base raster (normally fuel or elevation) to get the geotransform</source>
        <comment>BaseContext</comment>
        <translation>Raster base para posicionar el resultado (normalmente fuels o elevacion)</translation>
    </message>
    <message>
        <location filename="../algorithm_deprecated.py" line="90"/>
        <source>Simulator log file (normally firesim_yymmdd_HHMMSS/results/LogFile.txt)</source>
        <translation>Archivo de registro de simulación (normalmente firesim_yymmdd_HHMMSS/results/LogFile.txt)</translation>
    </message>
</context>
<context>
    <name>IgnitionPointsSIMPP</name>
    <message>
        <location filename="../algorithm_postsimulation.py" line="131"/>
        <source>Output ignition point(s) layer</source>
        <translation>Capa de salida con punto(s) de ignición</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="199"/>
        <source>Simulator Post Processing</source>
        <translation type="obsolete">Post procesamiento de simulación</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="216"/>
        <source>Ignition Points</source>
        <translation>Puntos de ignición</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="113"/>
        <source>Base raster (normally fuel or elevation) to get the geotransform</source>
        <comment>BaseContext</comment>
        <translation>Raster base para posicionar el resultado (normalmente fuels o elevacion)</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="118"/>
        <source>Simulator log file (normally firesim_yymmdd_HHMMSS/results/IgnitionsHistory/ignitions_log.csv)</source>
        <translation type="obsolete">Archivo de registro de simulación (normalmente firesim_yymmdd_HHMMSS/results/IgnitionsHistory/ignitions_log.csv)</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="121"/>
        <source>Simulator log file (normally firesim_yymmdd_HHMMSS/results/{igni_wea_path})</source>
        <translation type="finished">Archivo de registro de simulación (normalmente firesim_yymmdd_HHMMSS/results/ignitions_weather_log.csv)</translation>
    </message>
</context>
<context>
    <name>InstanceDownloader</name>
    <message>
        <location filename="../algorithm_instance_downloader.py" line="65"/>
        <source>Select the instances to download</source>
        <translation>Seleccione las instancias a descargar</translation>
    </message>
    <message>
        <location filename="../algorithm_instance_downloader.py" line="156"/>
        <source>Instance Downloader</source>
        <translation>Descargador de instancias</translation>
    </message>
    <message>
        <location filename="../algorithm_instance_downloader.py" line="89"/>
        <source>optional</source>
        <translation>opcional</translation>
    </message>
    <message>
        <location filename="../algorithm_instance_downloader.py" line="89"/>
        <source>- leave empty for using selected filename and temporary path
- if current project is saved its path will be used
- else use absolute filenaming (.zip extension is suggested)
- or relative filenaming for users home directory (or default qgis launch path)

After downloading, the file will be unzipped and opened in the file browser
</source>
        <translation>- dejar vacío para usar el nombre de archivo seleccionado en ruta temporal
- si el proyecto actual está guardado se usará su ruta
- de lo contrario usar un nombre de archivo absoluto (.zip es sugerido)
- o un nombre de archivo relativo al directorio personal del usuario (o ruta de inicio por defecto de qgis)</translation>
    </message>
    <message>
        <location filename="../algorithm_instance_downloader.py" line="89"/>
        <source>Output file</source>
        <translation>Archivo de salida</translation>
    </message>
    <message>
        <location filename="../algorithm_instance_downloader.py" line="73"/>
        <source>Unzip the downloaded file</source>
        <translation>Descomprimir el archivo descargado</translation>
    </message>
    <message>
        <location filename="../algorithm_instance_downloader.py" line="81"/>
        <source>Show in file browser</source>
        <translation>Mostrar en el explorador de archivos</translation>
    </message>
    <message>
        <location filename="../algorithm_instance_downloader.py" line="171"/>
        <source>This convenience algorithm provides ready-to-simulate instances.
It replaces the following manual steps:
1. Browse to our GitHub releases page: &lt;a href=https://github.com/fire2a/C2F-W/releases/latest&gt;https://github.com/fire2a/C2F-W/releases/latest&lt;/a&gt;
2. Select an Asset to download the prepared instances for a fuel model as a zip file
3. Unzip and show in your file browser

&lt;i&gt;&lt;b&gt;If the process fails, it is likely due to internet access issues.&lt;br&gt;Please favor Ascii Grid format (.asc) over Geotiff (.tif)&lt;/b&gt;&lt;/i&gt;</source>
        <translation>Este algoritmo de conveniencia proporciona instancias listas para simular.
	Reemplaza los siguientes pasos manuales:
	1. Navegar hasta nuestra página de lanzamientos: &lt;a href=https://github.com/fire2a/C2F-W/releases/latest&gt;https://github.com/fire2a/C2F-W/releases/latest&lt;/a&gt;
	2. Seleccionar un activo para descargar las instancias preparadas para un modelo de combustible como un archivo zip
	3. Descomprimir y mostrar en tu explorador de archivos

		&lt;i&gt;&lt;b&gt;Si el proceso falla, probablemente se deba a problemas de acceso a internet.&lt;br&gt;Favor de preferir el formato Ascii Grid (.asc) sobre Geotiff (.tif)&lt;/b&gt;&lt;/i&gt;</translation>
    </message>
</context>
<context>
    <name>MatchAIIGrid</name>
    <message>
        <location filename="../algorithm_match_aiigrids.py" line="52"/>
        <source>Raster to modify</source>
        <translation>Raster a modificar</translation>
    </message>
    <message>
        <location filename="../algorithm_match_aiigrids.py" line="60"/>
        <source>Raster to match to</source>
        <translation>Raster base para hacer coincidir/calzar</translation>
    </message>
    <message>
        <location filename="../algorithm_match_aiigrids.py" line="69"/>
        <source>CLI arguments</source>
        <translation>Argumentos de línea de commandos (CLI)</translation>
    </message>
    <message>
        <location filename="../algorithm_match_aiigrids.py" line="78"/>
        <source>Matched raster</source>
        <translation>Raster coincidente/calzado</translation>
    </message>
    <message>
        <location filename="../algorithm_match_aiigrids.py" line="193"/>
        <source>Match AII Grids</source>
        <translation>Calzar AII Grids</translation>
    </message>
    <message>
        <location filename="../algorithm_match_aiigrids.py" line="196"/>
        <source>Utils</source>
        <translation>Utilidades</translation>
    </message>
    <message>
        <location filename="../algorithm_match_aiigrids.py" line="211"/>
        <source>Simplifies using gdal translate to &lt;b&gt;clip extent, then resize and replace geotransform&lt;/b&gt; to match an ascii raster into another&lt;br&gt;&lt;br&gt;
            useful cli_args: -r {nearest,bilinear,cubic,cubicspline,lanczos,average,mode} (default nearest)&lt;br&gt;&lt;br&gt;
            not implemented: dealing with CRSs or nodatas.
            </source>
        <translation type="finished">Simplifica el uso de gdal translate para &lt;b&gt;recortar la extensión, luego redimensionar y reemplazar la geotransformación&lt;/b&gt; para hacer coincidir un raster ascii en otro&lt;br&gt;&lt;br&gt;
		algunos argumentos útiles: -r {nearest,bilinear,cubic,cubicspline,lanczos,average,mode} (predeterminado nearest)&lt;br&gt;&lt;br&gt;
		no implementado: manejo de CRS o nodatas.
	</translation>
    </message>
</context>
<context>
    <name>MessagesSIMPP</name>
    <message>
        <location filename="../algorithm_postsimulation.py" line="571"/>
        <source>Base raster (normally fuel or elevation) to get the geotransform</source>
        <comment>BaseContext</comment>
        <translation>Raster base para posicionar el resultado (normalmente fuels o elevacion)</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="579"/>
        <source>Sample Messages file (normally firesim_yymmdd_HHMMSS/results/Messages/MessagesFile01.csv)
All ChosenName[0-9]*.csv files will be loaded</source>
        <translation>Archivo de mensajes de muestra (normalmente firesim_yymmdd_HHMMSS/results/Messages/MessagesFile01.csv)
		Todos los archivos del patrón ChosenName[0-9]*.csv serán cargados</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="592"/>
        <source>Output propagation digraph layer</source>
        <translation>Capa de salida del grafo de propagación</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="600"/>
        <source>Output pickled messages file (needed by BC or DPV metrics, defaults to results/Messages/messages.pickle)</source>
        <translation>Archivo de mensajes de salida en formato pickle (necesario para métricas BC o DPV, por defecto en results/Messages/messages.pickle)</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="727"/>
        <source>Propagation DiGraph</source>
        <translation>Grafo dirigido de propagación</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="736"/>
        <source>Warning: Uncheck &apos;Open output file after running algorithm&apos; if the graph is too big or your computer too slow.</source>
        <translation>Advertencia: Desmarca 'Abrir archivo de salida después de ejecutar el algoritmo' si el grafo es demasiado grande o tu computadora es muy lenta.</translation>
    </message>
</context>
<context>
    <name>MeteoAlgo</name>
    <message>
        <location filename="../algorithm_meteo.py" line="57"/>
        <source>Where? Single point vector layer, else the center of the current map will be used.</source>
        <translation>¿Dónde? Capa vectorial con un único punto, de lo contrario se usará el centro del mapa actual.</translation>
    </message>
    <message>
        <location filename="../algorithm_meteo.py" line="68"/>
        <source>Quantile of daily maximum temperature</source>
        <translation>Cuantiles de temperatura máxima diaria</translation>
    </message>
    <message>
        <location filename="../algorithm_meteo.py" line="79"/>
        <source>Start Hour</source>
        <translation>Hora de inicio</translation>
    </message>
    <message>
        <location filename="../algorithm_meteo.py" line="88"/>
        <source>Step resolution in minutes (time between rows) - Not implemented yet</source>
        <translation>Resolución del paso en minutos (tiempo entre filas) - Aún no implementado</translation>
    </message>
    <message>
        <location filename="../algorithm_meteo.py" line="98"/>
        <source>Lenght of each scenario (number of rows) - Implementing hourly weather scenarios only.</source>
        <translation>Longitud de cada escenario (número de filas) - Duración de una hora entre filas.</translation>
    </message>
    <message>
        <location filename="../algorithm_meteo.py" line="108"/>
        <source>Number of scenarios to generate</source>
        <translation>Número de escenarios a generar</translation>
    </message>
    <message>
        <location filename="../algorithm_meteo.py" line="119"/>
        <source>Output folder</source>
        <translation>Carpeta de salida</translation>
    </message>
    <message>
        <location filename="../algorithm_meteo.py" line="206"/>
        <source>Meteo Kitral</source>
        <translation>Meteo Kitral</translation>
    </message>
    <message>
        <location filename="../algorithm_meteo.py" line="209"/>
        <source>Utils</source>
        <translation>Utilidades</translation>
    </message>
</context>
<context>
    <name>MultiObjectiveRasterKnapsackAlgorithm</name>
    <message>
        <location filename="../algorithm_knapsack.py" line="655"/>
        <source>Input rasters</source>
        <translation>Rasters de entrada</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="666"/>
        <source>Raster Configuration Matrix (use same order than input rasters)</source>
        <translation>Matriz de configuración de raster (usar el mismo orden que los rasters de entrada)</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="676"/>
        <source>Raster Knapsack Output layer</source>
        <translation>Capa de salida del Knapsack de raster</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="679"/>
        <source>Write debugging plots to the same directory as the output layer, includes: observations, scaled values, capacity violin plots &amp; solution stats</source>
        <translation>Escribir gráficos de depuración en el mismo directorio que la capa de salida, incluye: observaciones, valores escalados, gráficos de violín de capacidad y estadísticas de solución</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="689"/>
        <source>Relax excluding nodata values from any to all (layers containing nodata will exclude its pixel from the model)</source>
        <translation>Relajar la exclusión de valores nodata desde alguno a todos (las capas que contienen nodata excluirán sus píxeles del modelo)</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="849"/>
        <source>Multi Objective Raster Knapsack</source>
        <translation>Knapsack de raster multi objetivo</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="852"/>
        <source>Decision Optimization</source>
        <translation>Optimización de decisiones</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="867"/>
        <source>Optimizes a multi objective knapsack problem using layers as values and/or weights, returns a layer with the selected pixels.</source>
        <translation>Optimiza un problema de knapsack multi objetivo usando capas como valores y/o pesos, devuelve una capa con los píxeles seleccionados.</translation>
    </message>
    <message>
	<location filename="../algorithm_knapsack.py" line="878"/>
	<source>&lt;b&gt;1.&lt;/b&gt; Select a list of rasters to be used as values (to maximize or minimize) or weights (to be capacity constrained).
	    (drag to reorder the rasters to match the matrix)

	    &lt;b&gt;2.&lt;/b&gt; Complete the matrix datasheet in the same order as 1.:
	    &lt;b&gt;- value_rescaling&lt;/b&gt;: minmax, onehot, standard, robust or pass for no rescaling.
		&lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMax.html&quot;&gt;MinMax&lt;/a&gt; is default if only a value_weight is provided.
		&lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html&quot;&gt;OneHotEncoder&lt;/a&gt; is for categorical data, e.g., fuel models.
		MinMax and OneHot outputs into [0,1] range, &lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html&quot;&gt;Standard Scaler&lt;/a&gt; (x - &amp;mu;) / &amp;sigma; and &lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.RobustScaler.html&quot;&gt;Robust Scaler&lt;/a&gt; (same without outliers) not
	    &lt;b&gt;- value_weight&lt;/b&gt;: Any real number, although 0 doesn&apos;t make sense, &lt;i&gt;negative values are for minimizing instead of maximizing&lt;/i&gt;
	    &lt;b&gt;- capacity_sense&lt;/b&gt;, whether &lt;i&gt;at most or at least&lt;/i&gt;, use any of: &quot;&amp;lt;=, &amp;le;, le, ub&quot; or &quot;&amp;gt;=, &amp;ge;, ge, lb&quot;, respectively.
	    &lt;b&gt;- capacity_ratio&lt;/b&gt;: A real number, inside (-1,1). Internally it&apos;s multiplied by the &lt;i&gt;sum of all weights of that layer&lt;/i&gt;. E.g., 0.5 selects (at most or at least) half of the pixels, if all weights (values of that raster) are equal.
	    &lt;b&gt;3. [speed-up]&lt;/b&gt; Stop visually debugging your calculations by disabling the plots option in Advanced Parameters (writing the plots can take a while).

	    A new raster with selected, not selected and undecided pixels will be created. The undecided pixels means the solver failed to terminate fully; modifying solver options can mitigate this issue.

	    The classical knapsack problem is NP-hard, so a MIP solver engine is used to find &quot;nearly&quot; the optimal solution (**), because -often- is asymptotically hard to prove the optimal value. So a default gap of 0.5% and a timelimit of 5 minutes cuts off the solver run. The user can experiment with these parameters to trade-off between accuracy, speed and instance size(*). On Windows closing the blank terminal window will abort the run!

	    By using Pyomo, several MIP solvers can be used: CBC, GLPK, Gurobi, CPLEX or Ipopt; If they&apos;re accessible through the system PATH, else the executable file can be selected by the user. Installation of solvers is up to the user.

	    Although windows version is bundled with CBC unsigned binaries, so their users may face a &quot;Windows protected your PC&quot; warning, please avoid pressing the &quot;Don&apos;t run&quot; button, follow the &quot;More info&quot; link, scroll then press &quot;Run anyway&quot;. Nevertheless windows cbc does not support multithreading, so ignore that warning (or switch to Linux).

	    (*): Complexity can be reduced greatly by rescaling and/or rounding values into integers, or even better coarsing the raster resolution (see gdal translate resolution).
	    (**): There are specialized knapsack algorithms that solve in polynomial time, but not for every data type combination; hence using a MIP solver is the most flexible approach.

	    </source>
	    <translation>&lt;b&gt;1.&lt;/b&gt; Selecciona una lista de rasters a usar como valores (para maximizar o minimizar) o pesos (para ser limitados por la capacidad).
	    (arrastra para reordenar los rasters para que coincidan con la matriz)

	    &lt;b&gt;2.&lt;/b&gt; Completa la hoja de datos de la matriz en el mismo orden que 1.:
	    &lt;b&gt;- value_rescaling&lt;/b&gt;: minmax, onehot, standard, robust o pass para no reescalar.
		&lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMax.html&quot;&gt;MinMax&lt;/a&gt; es el valor predeterminado si solo se proporciona un value_weight.
		&lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html&quot;&gt;OneHotEncoder&lt;/a&gt; es para datos categóricos, por ejemplo, modelos de combustible.
		MinMax y OneHot producen valores entre [0,1], &lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html&quot;&gt;Standard Scaler&lt;/a&gt; (x - &amp;mu;) / &amp;sigma; y &lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.RobustScaler.html&quot;&gt;Robust Scaler&lt;/a&gt; (lo mismo sin valores atípicos) no
	    &lt;b&gt;- value_weight&lt;/b&gt;: Cualquier número real, aunque 0 no tiene sentido, &lt;i&gt;los valores negativos son para minimizar en lugar de maximizar&lt;/i&gt;
	    &lt;b&gt;- capacity_sense&lt;/b&gt;, ya sea &lt;i&gt;a lo sumo o a lo menos&lt;/i&gt;, usa cualquiera de: &quot;&amp;lt;=, &amp;le;, le, ub&quot; o &quot;&amp;gt;=, &amp;ge;, ge, lb&quot;, respectivamente.
	    &lt;b&gt;- capacity_ratio&lt;/b&gt;: Un número real, dentro de (-1,1). Internamente se multiplica por la &lt;i&gt;suma de todos los pesos de esa capa&lt;/i&gt;. Por ejemplo, 0.5 selecciona (a lo sumo o a lo menos) la mitad de los píxeles, si todos los pesos (valores de ese raster) son iguales.
	    &lt;b&gt;3. [para más velocidad]&lt;/b&gt; Detén la depuración visual de tus cálculos deshabilitando la opción de gráficos en Parámetros Avanzados (escribir los gráficos puede llevar un tiempo).

	    Un nuevo raster con píxeles seleccionados, no seleccionados y no decididos será creado. Los píxeles no decididos significan que el solucionador no pudo terminar completamente; modificar las opciones del solucionador puede mitigar este problema.

	    El problema clásico del knapsack es NP-hard, por lo que se utiliza un motor de solucionador MIP para encontrar &quot;casi&quot; la solución óptima (**), porque -a menudo- es asintóticamente difícil probar el valor óptimo. Así que un margen predeterminado de 0.5% y un límite de tiempo de 5 minutos cortan la ejecución del solucionador. El usuario puede experimentar con estos parámetros para equilibrar entre precisión, velocidad y tamaño de instancia (*). En Windows, cerrar la ventana de terminal en blanco abortará la ejecución.

	    Al usar Pyomo, se pueden utilizar varios solucionadores MIP: CBC, GLPK, Gurobi, CPLEX o Ipopt; Si están accesibles a través de la ruta del sistema, de lo contrario el usuario puede seleccionar el archivo ejecutable. La instalación de los solucionadores es responsabilidad del usuario.

	    Aunque la versión de Windows viene con binarios CBC sin firmar, por lo que sus usuarios pueden enfrentar una advertencia de &quot;Windows protegió tu PC&quot;, por favor evita presionar el botón &quot;No ejecutar&quot;, sigue el enlace &quot;Más información&quot;, desplázate y presiona &quot;Ejecutar de todos modos&quot;. Sin embargo, el CBC de Windows no admite multihilo, así que ignora esa advertencia (o cambia a Linux).

	    (*): La complejidad puede reducirse enormemente reescalando y/o redondeando los valores en enteros, o incluso mejor, reduciendo la resolución del raster (ver gdal translate resolution).
	    (**): Existen algoritmos especializados de knapsack que resuelven en tiempo polinómico, pero no para cada combinación de tipo de datos; por lo tanto, usar un solucionador MIP es el enfoque más flexible.</translation>
    </message>
</context>
<context>
    <name>PARasterKnapsackAlgorithm</name>
    <message>
        <location filename="../algorithm_knapsack.py" line="924"/>
        <source>Protected area layer</source>
        <translation>Capa de área protegida</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="933"/>
        <source>Strategy for the protected pixels</source>
        <translation>Estrategia para los píxeles protegidos</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="933"/>
        <source>Make protected pixels unselectable</source>
        <translation>Hacer que los píxeles protegidos no sean seleccionables</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="933"/>
        <source>Reselection prioritizing pixels neighboring the protected area</source>
        <translation>Re-selección priorizando píxeles vecinos al área protegida</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="946"/>
        <source>Values layer (if blank 1&apos;s will be used)</source>
        <translation>Capa de valores (si está en blanco se usarán 1's)</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="955"/>
        <source>Weights layer (if blank 1&apos;s will be used)</source>
        <translation>Capa de pesos (si está en blanco se usarán 1's)</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="964"/>
        <source>Capacity ratio (1 = weight.sum)</source>
        <translation>Relación de capacidad (1 = suma de todos los pesos de la capa)</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="977"/>
        <source>Raster Knapsack Output layer</source>
        <translation>Capa de salida del Knapsack de raster</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="1217"/>
        <source>Raster Knapsack with Protected Area</source>
        <translation>Knapsack de raster con área protegida</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="1220"/>
        <source>Decision Optimization</source>
        <translation>Optimización de decisiones</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="1235"/>
        <source>Optimizes the knapsack problem by incorporating protected area (pixels) that the algorithm cannot select.</source>
        <translation>Optimiza el problema del knapsack incorporando un área protegida (píxeles) que el algoritmo no puede seleccionar.</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="1246"/>
        <source>Optimizes the knapsack problem by incorporating protected area (pixels) that the algorithm cannot select. 

		&lt;b&gt;1. Select the protected pixels layer:&lt;/b&gt; 
		This must be a raster fully populated with 0s and 1s. Pixels with a value of 1 will be treated as protected, while those with a value of 0 will be considered non-protected.

		It is crucial that the raster contains no missing values and only binary values (0 and 1) to ensure the algorithm functions correctly.
		
		&lt;b&gt;2. Choose the strategy to apply to protected pixels:&lt;/b&gt;
		Two strategies are available:

		Strategy 1 – Make protected pixels unselectable:
		This strategy excludes pixels classified as protected from selection and solves the knapsack problem using only non-protected pixels.

		Strategy 2 – Reselection prioritizing pixels neighboring the protected area:
		This strategy involves first solving the classic knapsack problem using the provided value and weight layers. Pixels selected outside the protected area are retained, while those selected within the protected area are re-optimized by relocating them toward its border.
	    </source>
        <translation type="finished">Optimiza el problema del knapsack incorporando un área protegida (píxeles) que el algoritmo no puede seleccionar.

		&lt;b&gt;1. Selecciona la capa de píxeles protegidos:&lt;/b&gt;
		Esta debe ser un raster completamente poblado con 0s y 1s. Los píxeles con un valor de 1 serán tratados como protegidos, mientras que aquellos con un valor de 0 serán considerados no protegidos.

		Es crucial que el raster no contenga valores faltantes y solo valores binarios (0 y 1) para asegurar que el algoritmo funcione correctamente.

		&lt;b&gt;2. Elige la estrategia a aplicar a los píxeles protegidos:&lt;/b&gt;
		Se encuentran disponibles dos estrategias:

		Estrategia 1 – Hacer que los píxeles protegidos no sean seleccionables:
		Esta estrategia excluye los píxeles clasificados como protegidos de la selección y resuelve el problema del knapsack utilizando solo los píxeles no protegidos.

		Estrategia 2 – Re-selección priorizando los píxeles vecinos al área protegida:
		Esta estrategia implica resolver primero el problema clásico del knapsack utilizando las capas de valor y peso proporcionadas. Los píxeles seleccionados fuera del área protegida se mantienen, mientras que aquellos seleccionados dentro del área protegida se re-optimizan reubicándolos hacia su borde.
	    </translation>
    </message>
</context>
<context>
    <name>PolyTreatmentAlgorithm</name>
    <message>
        <location filename="../algorithm_treatment.py" line="757"/>
        <source>Input Polygons Layer</source>
        <translation>Capa de polígonos de entrada</translation>
    </message>
    <message>
        <location filename="../algorithm_treatment.py" line="765"/>
        <source>Attribute table field name for {self.IN_TRT}</source>
        <translation>Atributo de la tabla de atributos para {self.IN_TRT}</translation>
    </message>
    <message>
        <location filename="../algorithm_treatment.py" line="779"/>
        <source>Attribute table field name for {field_value} [0s if not provided]</source>
        <translation>Atributo de la tabla de atributos para {field_value} [0s si no se proporciona]</translation>
    </message>
    <message>
        <location filename="../algorithm_treatment.py" line="792"/>
        <source>Treatments table (fid,treatment,value,value/m2,cost,cost/m2)</source>
        <translation>Tabla de tratamientos (fid,treatment,value,value/m2,cost,cost/m2)</translation>
    </message>
    <message>
        <location filename="../algorithm_treatment.py" line="801"/>
        <source>Total Area</source>
        <translation>Área total</translation>
    </message>
    <message>
        <location filename="../algorithm_treatment.py" line="813"/>
        <source>Total Budget</source>
        <translation>Presupuesto total</translation>
    </message>
    <message>
        <location filename="../algorithm_treatment.py" line="1028"/>
        <source>Polygon Treatment</source>
        <translation>Tratamiento de polígonos</translation>
    </message>
    <message>
        <location filename="../algorithm_treatment.py" line="829"/>
        <source>Set invalid geometry check to GeometrySkipInvalid (more options clicking the wrench on the input poly layer)</source>
        <translation>Establecer la verificación de geometría inválida a GeometrySkipInvalid (más opciones haciendo clic en la llave inglesa en la capa de polígonos de entrada)</translation>
    </message>
    <message>
        <location filename="../algorithm_treatment.py" line="1031"/>
        <source>Decision Optimization</source>
        <translation>Optimización de decisiones</translation>
    </message>
    <message>
	<location filename="../algorithm_treatment.py" line="1047"/>
	<source>&lt;b&gt;Objetive:&lt;/b&gt; Maximize the changed value of the treated polygons&lt;br&gt; 
	    &lt;b&gt;Decisions:&lt;/b&gt; Which treatment to apply to each polygon (or no change)&lt;br&gt;
	    &lt;b&gt;Contraints:&lt;/b&gt;&lt;br&gt;
	    (a) fixed+area costs less than budget&lt;br&gt;
	    (b) treated area less than total area&lt;br&gt; 
	    &lt;b&gt;Inputs:&lt;/b&gt;&lt;br&gt;
	    (i) A polygon layer with &lt;b&gt;current&lt;/b&gt; attributes: [fid],&lt;b&gt;treatment, value, value/m2&lt;/b&gt;&lt;br&gt;
	    (ii) A .csv table defining &lt;b&gt;target&lt;/b&gt; treatments: &lt;b&gt;fid, treatment, value, value/m2, cost, cost/m2&lt;/b&gt; (use these column names)&lt;br&gt;
	    - fid is the feature id of each polygon so it&apos;s given in the attribute table, but must be specified in the .csv table&lt;br&gt;
	    - current &amp; target treatment are just strings, but each polygon needs at least one feasible treatment (one row)&lt;br&gt;
	    - current &amp; target values[/m2] weight towards the objective when no change (keep current) or a target treatment is recommended&lt;br&gt;
	    (iii) &lt;b&gt;Budget&lt;/b&gt; (same units than costs)&lt;br&gt;
	    (iv) &lt;b&gt;Area&lt;/b&gt; (same units than the geometry of the polygons)&lt;br&gt;
	    &lt;br&gt;
	    &lt;br&gt;
	    sample: &lt;a href=&apos;</source>
    <translation>&lt;b&gt;Objetivo:&lt;/b&gt; Maximizar el valor cambiado de los polígonos tratados&lt;br&gt;
	    &lt;b&gt;Decisiones:&lt;/b&gt; Qué tratamiento aplicar a cada polígono (o sin cambios)&lt;br&gt;
	    &lt;b&gt;Restricciones:&lt;/b&gt;&lt;br&gt;
	    (a) costos fijos+área menores que el presupuesto&lt;br&gt;
	    (b) área tratada menor que el área total&lt;br&gt;
	    &lt;b&gt;Entradas:&lt;/b&gt;&lt;br&gt;
	    (i) Una capa de polígonos con atributos &lt;b&gt;actuales&lt;/b&gt;: [fid],&lt;b&gt;treatment, value, value/m2&lt;/b&gt;&lt;br&gt;
	    (ii) Una tabla .csv definiendo tratamientos &lt;b&gt;objetivo&lt;/b&gt;: &lt;b&gt;fid, treatment, value, value/m2, cost, cost/m2&lt;/b&gt; (usar estos nombres de columna)&lt;br&gt;
	    - fid es el id de la característica de cada polígono, por lo que se da en la tabla de atributos, pero debe especificarse en la tabla .csv&lt;br&gt;
	    - tratamiento actual y objetivo son solo cadenas, pero cada polígono necesita al menos un tratamiento factible (una fila)&lt;br&gt;
	    - valores actuales y objetivos[/m2] pesan hacia el objetivo cuando no hay cambio (mantener el actual) o se recomienda un tratamiento objetivo&lt;br&gt;
	    (iii) &lt;b&gt;Presupuesto&lt;/b&gt; (mismas unidades que los costos)&lt;br&gt;
	    (iv) &lt;b&gt;Área&lt;/b&gt; (mismas unidades que la geometría de los polígonos)&lt;br&gt;
	    &lt;br&gt;
	    &lt;br&gt;
	    ejemplo: &lt;a href=&apos;</translation>
    </message>
</context>
<context>
    <name>PolygonKnapsackAlgorithm</name>
    <message>
        <location filename="../algorithm_knapsack.py" line="71"/>
        <source>Input Polygons Layer</source>
        <translation>Capa de polígonos de entrada</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="79"/>
        <source>Attribute table field name for VALUE (if blank 1&apos;s will be used)</source>
        <translation>Atributo de la tabla de atributos para el VALOR (si está en blanco se usarán 1's)</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="92"/>
        <source>Attribute table field name for WEIGHT (if blank polygon&apos;s area will be used)</source>
        <translation>Atributo de la tabla de atributos para el PESO (si está en blanco se usará el área del polígono)</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="105"/>
        <source>Capacity ratio (1 = weight.sum)</source>
        <translation>Relación de capacidad (1 = suma de todos los pesos de la capa)</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="117"/>
        <source>Polygon Knapsack Output Layer</source>
        <translation>Capa de salida del Knapsack de polígonos</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="119"/>
        <source>Set invalid geometry check to GeometrySkipInvalid (more options clicking the wrench on the input poly layer)</source>
        <translation>Establecer la verificación de geometría inválida a GeometrySkipInvalid (más opciones haciendo clic en la llave inglesa en la capa de polígonos de entrada)</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="299"/>
        <source>Polygon Knapsack</source>
        <translation>Knapsack de polígonos</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="302"/>
        <source>Decision Optimization</source>
        <translation>Optimizador de decisiones</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="317"/>
        <source>Optimizes the classical knapsack problem using polygons with values and/or weights attributes, returns a polygon layer with the selected polygons.</source>
        <translation>Optimiza el clásico problema de la mochila &quot;Knapsack&quot; usando polígonos con atributos de valores y/o pesos, devuelve una capa de polígonos con los polígonos seleccionados.</translation>
    </message>
</context>
<context>
    <name>PostSimulationAlgorithm</name>
    <message>
        <location filename="../algorithm_postsimulation.py" line="233"/>
        <source>Base raster (normally fuel or elevation) to get the geotransform</source>
        <comment>BaseContext</comment>
        <translation>Raster base para posicionar el resultado (normalmente fuels o elevacion)</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="241"/>
        <source>Enable propagation directed graph</source>
        <translation>Habilitar grafo dirigido de propagación</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="249"/>
        <source>Enable propagation scars polygons</source>
        <translation>Habilitar polígonos de cicatrices de propagación</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="259"/>
        <source>Simulation Results directory (normally firesim_yymmdd_HHMMSS/results)</source>
        <translation>Directorio de resultados de simulación (normalmente firesim_yymmdd_HHMMSS/results)</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="268"/>
        <source>Output directory</source>
        <comment>BaseContext</comment>
        <translation>Directorio de salida</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="324"/>
        <source>Ignition Points</source>
        <translation>Puntos de ignición</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="424"/>
        <source>Final Scars</source>
        <translation>Cicatrices finales</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="433"/>
        <source>BurnProbability</source>
        <translation>ProbabilidadDeQuema</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="439"/>
        <source>Burn Probability</source>
        <translation>Probabilidad de quema</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="497"/>
        <source>PropagationDirectedGraph</source>
        <translation>DiGrafoDePropagación</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="521"/>
        <source>Bundle</source>
        <translation>Paquete</translation>
    </message>
    <message>
	<location filename="../algorithm_postsimulation.py" line="539"/>
	<source>This algorithm attempts to load everything from a simulation results directory, in a convenient but slower than selecting one of the following algorithms in the &lt;b&gt;PostProcessing group&lt;/b&gt;. Check each one for more details.

	    Although &lt;b&gt;Propagation Directed Graph&lt;/b&gt; output is fundamental to risk metrics such as DPV and BC: &lt;b&gt;Warning: Enabling it here can hang-up your system&lt;/b&gt;, around 300.000 arrows is manageable for a regular laptop&lt;br&gt;
	    Be safe by counting them first: Go to results/Messages folder:&lt;br&gt;
	     - using bash $ wc -l Messages*csv&lt;br&gt;
	     - using PowerShell &gt; Get-Content Messages*.csv | Measure-Object -Line&lt;br&gt;
	    To process but not display them, use Propagation DiGraph algorithm directly, unchecking &apos;Open output file after running algorithm&apos;&lt;br&gt;&lt;br&gt;
	    &lt;i&gt;The visualization alternative is &lt;b&gt;Propagation Fire Scars&lt;/b&gt;. Or even &lt;b&gt;Final Fire Scar&lt;/b&gt;, recommended for very large simulations&lt;/i&gt;
	    </source>
        <translation>Este algoritmo intenta cargar todo desde un directorio de resultados de simulación, de manera conveniente pero más lenta que seleccionar uno de los siguientes algoritmos en el grupo &lt;b&gt;PostProcesamiento&lt;/b&gt;. Consulta cada uno para obtener más detalles.

	    Aunque la salida del &lt;b&gt;Grafo Dirigido de Propagación&lt;/b&gt; es fundamental para métricas de riesgo como DPV y BC: &lt;b&gt;Advertencia: Habilitarlo aquí puede colgar tu sistema&lt;/b&gt;, alrededor de 300.000 flechas es manejable para una laptop regular&lt;br&gt;
	    Es más seguro contar antes de ejecutar: Ve a la carpeta results/Messages:&lt;br&gt;
	     - usando bash $ wc -l Messages*csv&lt;br&gt;
	     - usando PowerShell &gt; Get-Content Messages*.csv | Measure-Object -Line&lt;br&gt;
	    Para procesarlos pero no mostrarlos, usa el algoritmo Grafo Dirigido de Propagación directamente, desmarcando 'Abrir archivo de salida después de ejecutar el algoritmo'&lt;br&gt;&lt;br&gt;
	    &lt;i&gt;La alternativa de visualización es &lt;b&gt;Cicatrices de Fuego por Propagación&lt;/b&gt;. O incluso &lt;b&gt;Cicatriz Final del Fuego&lt;/b&gt;, recomendado para simulaciones muy grandes&lt;/i&gt;
	</translation>
    </message>
</context>
<context>
    <name>RasterKnapsackAlgorithm</name>
    <message>
        <location filename="../algorithm_knapsack.py" line="340"/>
        <source>Values layer (if blank 1&apos;s will be used)</source>
        <translation>Capa de valores (si está en blanco se usarán 1's)</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="349"/>
        <source>Weights layer (if blank 1&apos;s will be used)</source>
        <translation>Capa de pesos (si está en blanco se usarán 1's)</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="358"/>
        <source>Capacity ratio (1 = weight.sum)</source>
        <translation>Ratio de capacidad (1 = suma de todos los pesos)</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="371"/>
        <source>Raster Knapsack Output layer</source>
        <translation>Capa de salida del Knapsack raster</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="555"/>
        <source>Raster Knapsack</source>
        <translation>Raster Knapsack</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="558"/>
        <source>Decision Optimization</source>
        <translation>Optimizador de decisiones</translation>
    </message>
    <message>
        <location filename="../algorithm_knapsack.py" line="573"/>
        <source>Optimizes the classical knapsack problem using layers as values and/or weights, returns a layer with the selected pixels.</source>
        <translation>Optimiza el clásico problema de la mochila &quot;Knapsack&quot; usando capas como valores y/o pesos, devuelve una capa con los píxeles seleccionados.</translation>
    </message>
    <message>
	<location filename="../algorithm_knapsack.py" line="584"/>
	<source>By selecting a Values layer and/or a Weights layer, and setting the bound on the total capacity, a layer that maximizes the sum of the values of the selected pixels is created.

	    A new raster (default .gpkg) will show selected pixels in red and non-selected green (values 1, 0 and no-data=-1).

	    The capacity constraint is set up by choosing a ratio (between 0 and 1), that multiplies the sum of all weights (except no-data). Hence 1 selects all pixels that aren&apos;t no-data in both layers.

	    This raster knapsack problem is NP-hard, so a MIP solver engine is used to find &quot;nearly&quot; the optimal solution (**), because -often- is asymptotically hard to prove the optimal value. So a default gap of 0.5% and a timelimit of 5 minutes cuts off the solver run. The user can experiment with these parameters to trade-off between accuracy, speed and instance size(*). On Windows closing the blank terminal window will abort the run!

	    By using Pyomo, several MIP solvers can be used: CBC, GLPK, Gurobi, CPLEX or Ipopt; If they&apos;re accessible through the system PATH, else the executable file can be selected by the user. Installation of solvers is up to the user.

	    Although windows version is bundled with CBC unsigned binaries, so their users may face a &quot;Windows protected your PC&quot; warning, please avoid pressing the &quot;Don&apos;t run&quot; button, follow the &quot;More info&quot; link, scroll then press &quot;Run anyway&quot;. Nevertheless windows cbc does not support multithreading, so ignore that warning (or switch to Linux).

	    (*): Complexity can be reduced greatly by rescaling and/or rounding values into integers, or even better coarsing the raster resolution (see gdal translate resolution).
	    (**): There are specialized knapsack algorithms that solve in polynomial time, but not for every data type combination; hence using a MIP solver is the most flexible approach.

	    ----

	    USE CASE:

	    If you want to determine where to allocate fuel treatments throughout the landscape to protect a specific value that is affected by both the fire and the fuel treatments, use the following:

		- Values: Downstream Protection Value layer calculated with the respective value that you want to protect.

		- Weights: The layer, that contains the value that you want to protect and that is affected also by the fuel treatments (e.g., animal habitat).
	    If you want to determine where to allocate fuel treatments through out the landscape to protect and specific value that is affected by both, the fire and the fuel treatments use: 
	    </source>
        <translation>Al seleccionar una capa de Valores y/o una capa de Pesos, y estableciendo el límite en la capacidad total, se crea una capa que maximiza la suma de los valores de los píxeles seleccionados.

	    Se generará un nuevo raster (por defecto .gpkg) que mostrará los píxeles seleccionados en rojo y los no seleccionados en verde (valores 1, 0 y no-data=-1).

	    La restricción de capacidad se establece eligiendo una relación (entre 0 y 1), que multiplica la suma de todos los pesos (excepto no-data). Por lo tanto, 1 selecciona todos los píxeles que no son no-data en ambas capas.

	    Este problema del knapsack raster es NP-difícil, por lo que se utiliza un motor de MIP solver para encontrar &quot;casi&quot; la solución óptima (**), porque -a menudo- es asintóticamente difícil probar el valor óptimo. Por lo tanto, un gap predeterminado del 0.5% y un límite de tiempo de 5 minutos cortan la ejecución del solucionador. El usuario puede experimentar con estos parámetros para equilibrar entre precisión, velocidad y tamaño de instancia(*). En Windows, cerrar la ventana terminal en blanco abortará la ejecución.

	    Al usar Pyomo, se pueden utilizar varios MIP solvers: CBC, GLPK, Gurobi, CPLEX o Ipopt; Si están accesibles a través de la ruta del sistema, de lo contrario el archivo ejecutable puede ser seleccionado por el usuario. La instalación de los solvers depende del usuario.

	    Aunque la versión de Windows viene con binarios CBC sin firmar, por lo que sus usuarios pueden enfrentar una advertencia &quot;Windows protegió tu PC&quot;, por favor evita presionar el botón &quot;No ejecutar&quot;, sigue el enlace &quot;Más información&quot;, desplázate y presiona &quot;Ejecutar de todos modos&quot;. Sin embargo, cbc en Windows no admite multihilo, así que ignora esa advertencia (o cambia a Linux).

	    (*): La complejidad se puede reducir enormemente al reescalar y/o redondear valores en enteros, o incluso mejor al reducir la resolución del raster (ver gdal translate resolution).
	(**): Existen algoritmos especializados en knapsack que resuelven en tiempo polinómico, pero no para cada combinación de tipo de datos; por lo tanto, usar un MIP solver es el enfoque más flexible.

	    ----

	    CASO DE USO:

	    Si deseas determinar dónde asignar tratamientos de combustible en todo el paisaje para proteger un valor específico que se ve afectado tanto por el fuego como por los tratamientos de combustible, utiliza lo siguiente:

		- Valores: Capa de Valor de Protección Descendente calculada con el valor respectivo que deseas proteger.

		- Pesos: La capa que contiene el valor que deseas proteger y que también se ve afectado por los tratamientos de combustible (por ejemplo, hábitat animal).
	    Si deseas determinar dónde asignar tratamientos de combustible en todo el paisaje para proteger un valor específico que se ve afectado tanto por el fuego como por los tratamientos de combustible, utiliza:
	    </translation>
    </message>
</context>
<context>
    <name>RasterTreatmentAlgorithm</name>
    <message>
        <location filename="../algorithm_treatment.py" line="488"/>
        <source>Raster layer for {raster}</source>
        <translation>Capa raster para {raster}</translation>
    </message>
    <message>
        <location filename="../algorithm_treatment.py" line="498"/>
        <source>Treatments Matrix (csv)</source>
        <translation>Matriz de tratamientos (csv)</translation>
    </message>
    <message>
        <location filename="../algorithm_treatment.py" line="507"/>
        <source>Total Area</source>
        <translation>Área total</translation>
    </message>
    <message>
        <location filename="../algorithm_treatment.py" line="518"/>
        <source>Total Budget</source>
        <translation>Presupuesto total</translation>
    </message>
    <message>
        <location filename="../algorithm_treatment.py" line="682"/>
        <source>Raster Treatment</source>
        <translation>Raster de Tratamientos</translation>
    </message>
    <message>
	<location filename="../algorithm_treatment.py" line="701"/>
	<source>&lt;b&gt;Objetive:&lt;/b&gt; Maximize the changed value of the treated raster&lt;br&gt; 
	    &lt;b&gt;Decisions:&lt;/b&gt; Which treatment to apply to each pixel (or no change)&lt;br&gt;
	    &lt;b&gt;Contraints:&lt;/b&gt;&lt;br&gt;
	    (a) treat cost * pixel area less than budget&lt;br&gt;
	    (b) treated area less than total area&lt;br&gt; 
	    &lt;b&gt;Inputs:&lt;/b&gt;&lt;br&gt;
	    (i) A .csv squared-table of &lt;b&gt;treatment transformation costs(/m2)&lt;/b&gt; (defines index encoding)&lt;br&gt;
	    (ii) A raster layer with &lt;b&gt;current treatments&lt;/b&gt; index values (encoded: 0..number of treatments-1)&lt;br&gt;
	    (iii) A raster layer with &lt;b&gt;current values&lt;/b&gt;&lt;br&gt;
	    (iv) A multiband raster layer with &lt;b&gt;target values&lt;/b&gt; (number of treatments == number of bands)&lt;br&gt;
	    (vi) &lt;b&gt;Budget&lt;/b&gt; (same units than costs)&lt;br&gt;
	    (vii) &lt;b&gt;Area&lt;/b&gt; (same units than pixel size of the raster)&lt;br&gt;
	    &lt;br&gt;
	    - consistency between rasters is up to the user&lt;br&gt;
	    - rasters &quot;must be saved to disk (for layers to have a publicSource != )&quot;&lt;br&gt;
	    - raster no data == -1 &lt;br&gt;
	    &lt;br&gt;
	    sample: &lt;a href=&apos;</source>
        <translation>&lt;b&gt;Objetivo:&lt;/b&gt; Maximizar el valor cambiado del raster tratado&lt;br&gt; 
	    &lt;b&gt;Decisiones:&lt;/b&gt; Qué tratamiento aplicar a cada píxel (o sin cambio)&lt;br&gt;
	    &lt;b&gt;Restricciones:&lt;/b&gt;&lt;br&gt;
	    (a) costo de tratamiento * área del píxel menos que el presupuesto&lt;br&gt;
	    (b) área tratada menor que el área total&lt;br&gt; 
	    &lt;b&gt;Entradas:&lt;/b&gt;&lt;br&gt;
	    (i) Una tabla cuadrada .csv de &lt;b&gt;costos de transformación de tratamientos(/m2)&lt;/b&gt; (define la codificación de índices)&lt;br&gt;
	    (ii) Una capa raster con valores de índice de &lt;b&gt;tratamientos actuales&lt;/b&gt; (codificados: 0..número de tratamientos-1)&lt;br&gt;
	    (iii) Una capa raster con &lt;b&gt;valores actuales&lt;/b&gt;&lt;br&gt;
	    (iv) Una capa raster multibanda con &lt;b&gt;valores objetivo&lt;/b&gt; (número de tratamientos == número de bandas)&lt;br&gt;
	    (vi) &lt;b&gt;Presupuesto&lt;/b&gt; (mismas unidades que los costos)&lt;br&gt;
	    (vii) &lt;b&gt;Área&lt;/b&gt; (mismas unidades que el tamaño del píxel del raster)&lt;br&gt;
	    &lt;br&gt;
	    - la consistencia entre rasters depende del usuario&lt;br&gt;
	    - los rasters &quot;deben guardarse en disco (para que las capas tengan un publicSource != )&quot;&lt;br&gt;
	    - no-data del raster == -1 &lt;br&gt;
	    &lt;br&gt;
            ejemplo: &lt;a href=&apos;</translation>
    </message>
</context>
<context>
    <name>RasterTreatmentTeamAlgorithm</name>
    <message>
        <location filename="../algorithm_treatment.py" line="81"/>
        <source>Raster layer for {raster}</source>
        <translation>Capa raster para {raster}</translation>
    </message>
    <message>
        <location filename="../algorithm_treatment.py" line="91"/>
        <source>Treatments transformation costs (csv)</source>
        <translation>Matriz de costos de transformación de tratamientos (csv)</translation>
    </message>
    <message>
        <location filename="../algorithm_treatment.py" line="100"/>
        <source>Total Area</source>
        <translation>Área total</translation>
    </message>
    <message>
        <location filename="../algorithm_treatment.py" line="111"/>
        <source>Total Budget</source>
        <translation>Presupuesto total</translation>
    </message>
    <message>
        <location filename="../algorithm_treatment.py" line="123"/>
        <source>Treatment areas &amp; budget (csv)</source>
        <translation>Áreas de tratamiento y presupuesto (csv)</translation>
    </message>
    <message>
        <location filename="../algorithm_treatment.py" line="134"/>
        <source>Teams on_cost, area, budget and abilities (csv)</source>
        <translation>Equipos: costo fijo, área, presupuesto y habilidades (csv headers: on_cost, area, budget, abilities)</translation>
    </message>
    <message>
        <location filename="../algorithm_treatment.py" line="145"/>
        <source>Raster tReatment</source>
        <translation>Raster de tRatamiento</translation>
    </message>
    <message>
        <location filename="../algorithm_treatment.py" line="148"/>
        <source>Raster tEam</source>
        <translation>Raster de Equipos</translation>
    </message>
    <message>
        <location filename="../algorithm_treatment.py" line="405"/>
        <source>Raster Treatment Team</source>
        <translation>Tratamiento con Equipos usando Rasters</translation>
    </message>
    <message>
	<location filename="../algorithm_treatment.py" line="424"/>
	<source>&lt;b&gt;Objetive:&lt;/b&gt; Maximize the changed value of the treated raster&lt;br&gt; 
	    &lt;b&gt;Decisions:&lt;/b&gt; Which treatment to apply by which team to each pixel (or no change)&lt;br&gt;
	    &lt;b&gt;Contraints:&lt;/b&gt;&lt;br&gt;
	    (a) all treat cost * pixel area(pxa) + team on_cost is less than &lt;b&gt;Budget&lt;/b&gt;&lt;br&gt;
	    (b) treat cost * pxa is less than &lt;b&gt;budget per treatment&lt;/b&gt;&lt;br&gt;
	    (c) treat cost * pxa is less than &lt;b&gt;budget per team&lt;/b&gt;&lt;br&gt;
	    (d) all treated area less than total &lt;b&gt;Area&lt;/b&gt;&lt;br&gt; 
	    (e) treated area less than &lt;b&gt;area per treatment&lt;/b&gt;&lt;br&gt; 
	    (f) treated area less than &lt;b&gt;area per team&lt;/b&gt;&lt;br&gt; 
	    (g) at most one treatment by one team per pixel&lt;br&gt;
	    (h) linkage between treating (h,w,r,e) and active teams (e) variables&lt;br&gt;
	    &lt;b&gt;Inputs:&lt;/b&gt;&lt;br&gt;
	    (i) A .csv squared-table of &lt;b&gt;treatment transformation costs(/m2)&lt;/b&gt; (defines index encoding)&lt;br&gt;
	    (ii) A raster layer with &lt;b&gt;current treatments&lt;/b&gt; indexed values (encoded: 0..number of treatments-1)&lt;br&gt;
	    (iii) A raster layer with &lt;b&gt;current values&lt;/b&gt;&lt;br&gt;
	    (iv) A multiband raster layer with &lt;b&gt;target values&lt;/b&gt; (number of treatments == number of bands)&lt;br&gt;
	    (vi) &lt;b&gt;Budget&lt;/b&gt; (same units than costs)&lt;br&gt;
	    (vii) &lt;b&gt;Area&lt;/b&gt; (same units than pixel size of the raster)&lt;br&gt;
	    (viii) A .csv table for each &lt;b&gt;treatment area and budget&lt;/b&gt; capacities&lt;br&gt;
	    (viii) A .csv table for each &lt;b&gt;team on_cost, area, budget and abilities&lt;/b&gt; (1s is able)&lt;br&gt;
	    &lt;br&gt;
	    - consistency between rasters is up to the user&lt;br&gt;
	    - rasters &quot;must be saved to disk (for layers to have a publicSource != )&quot;&lt;br&gt;
	    - raster no data == -1 &lt;br&gt;
	    &lt;br&gt;
	    sample: &lt;a href=&apos;</source>
        <translation>&lt;b&gt;Objetivo:&lt;/b&gt; Maximizar el valor cambiado del raster tratado&lt;br&gt; 
	    &lt;b&gt;Decisiones:&lt;/b&gt; Qué tratamiento aplicar por qué equipo a cada píxel (o sin cambio)&lt;br&gt;
	    &lt;b&gt;Restricciones:&lt;/b&gt;&lt;br&gt;
	    (a) todo costo de tratamiento * área del píxel(pxa) + costo fijo del equipo es menor que &lt;b&gt;Presupuesto&lt;/b&gt;&lt;br&gt;
	    (b) costo de tratamiento * pxa es menor que &lt;b&gt;presupuesto por tratamiento&lt;/b&gt;&lt;br&gt;
	    (c) costo de tratamiento * pxa es menor que &lt;b&gt;presupuesto por equipo&lt;/b&gt;&lt;br&gt;
	    (d) toda el área tratada menor que total &lt;b&gt;Área&lt;/b&gt;&lt;br&gt; 
	    (e) área tratada menor que &lt;b&gt;área por tratamiento&lt;/b&gt;&lt;br&gt; 
	    (f) área tratada menor que &lt;b&gt;área por equipo&lt;/b&gt;&lt;br&gt; 
	    (g) como máximo un tratamiento por un equipo por píxel&lt;br&gt;
	    (h) vinculación entre variables de tratamiento (h,w,r,e) y equipos activos (e)&lt;br&gt;
	    &lt;b&gt;Entradas:&lt;/b&gt;&lt;br&gt;
	    (i) Una tabla cuadrada .csv de &lt;b&gt;costos de transformación de tratamientos(/m2)&lt;/b&gt; (define la codificación de índices)&lt;br&gt;
	    (ii) Una capa raster con valores indexados de &lt;b&gt;tratamientos actuales&lt;/b&gt; (codificados: 0..número de tratamientos-1)&lt;br&gt;
	    (iii) Una capa raster con &lt;b&gt;valores actuales&lt;/b&gt;&lt;br&gt;
	    (iv) Una capa raster multibanda con &lt;b&gt;valores objetivo&lt;/b&gt; (número de tratamientos == número de bandas)&lt;br&gt;
	    (vi) &lt;b&gt;Presupuesto&lt;/b&gt; (mismas unidades que los costos)&lt;br&gt;
	    (vii) &lt;b&gt;Área&lt;/b&gt; (mismas unidades que el tamaño del píxel del raster)&lt;br&gt;
	    (viii) Una tabla .csv para cada &lt;b&gt;costo fijo del equipo, área, presupuesto y habilidades&lt;/b&gt; (1s es capaz)&lt;br&gt;
            &lt;br&gt;
	    - la consistencia entre rasters depende del usuario&lt;br&gt;
	    - los rasters &quot;deben guardarse en disco (para que las capas tengan un publicSource != )&quot;&lt;br&gt;
	    - no-data del raster == -1 &lt;br&gt;
	    &lt;br&gt;
	    ejemplo: &lt;a href=&apos;</translation>
    </message>
</context>
<context>
    <name>RasterTutorial</name>
    <message>
        <location filename="../algorithm_raster_tutorial.py" line="42"/>
        <source>Input Raster %s</source>
        <translation>Entrada Raster %s</translation>
    </message>
    <message>
        <location filename="../algorithm_raster_tutorial.py" line="43"/>
        <source>Output Raster</source>
        <translation>Salida Raster</translation>
    </message>
    <message>
        <location filename="../algorithm_raster_tutorial.py" line="53"/>
        <source>Output raster format .%s not supported</source>
        <translation>Formato de salida raster .%s no soportado</translation>
    </message>
</context>
<context>
    <name>SandboxAlgorithm</name>
    <message>
        <location filename="../algorithm_sandbox.py" line="208"/>
        <source>Input File</source>
        <translation>Archivo de entrada</translation>
    </message>
    <message>
        <location filename="../algorithm_sandbox.py" line="417"/>
        <source>AASandbox</source>
        <translation>AAZonaDePruebas</translation>
    </message>
    <message>
        <location filename="../algorithm_sandbox.py" line="448"/>
        <source>This is an example algorithm that takes a vector layer and creates a new identical one.</source>
        <translation>Este es un algoritmo de ejemplo que toma una capa vectorial y crea una nueva idéntica.</translation>
    </message>
    <message>
        <location filename="../algorithm_sandbox.py" line="455"/>
        <source>This is an example algorithm that takes a vector layer and creates a new identical one.
        It is meant to be used as an example of how to create your own algorithms and explain methods and variables used to do it. An algorithm like this will be available in all elements, and there is not need for additional work.
        All Processing algorithms should extend the QgsProcessingAlgorithm class.</source>
        <translation>Este es un algoritmo de ejemplo que toma una capa vectorial y crea una nueva idéntica.
	Su propósito es ser utilizado como ejemplo de cómo crear tus propios algoritmos y explicar los métodos y variables utilizados para hacerlo. Un algoritmo como este estará disponible en todos los elementos, y no se requiere trabajo adicional.
	Todos los algoritmos de procesamiento deben extender la clase QgsProcessingAlgorithm.</translation>
    </message>
</context>
<context>
    <name>ScarSIMPP</name>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1022"/>
        <source>Base raster (normally fuel or elevation) to get the geotransform</source>
        <comment>BaseContext</comment>
        <translation>Raster base para posicionar el resultado (normalmente fuels o elevacion)</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1030"/>
        <source>Sample Fire Scar file (normally firesim_yymmdd_HHMMSS/results/Grids/Grids[0-9]*/ForestGrid[0-9]*.csv)</source>
        <translation>Archivo de muestra de cicatriz de fuego (normalmente firesim_yymmdd_HHMMSS/results/Grids/Grids[0-9]*/ForestGrid[0-9]*.csv)</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1043"/>
        <source>Output final scar raster</source>
        <translation>Salida raster de cicatriz final</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1051"/>
        <source>Output propagation scars polygons</source>
        <translation>Salida de polígonos de cicatrices de propagación</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1060"/>
        <source>Output burn probability raster</source>
        <translation>Salida raster de probabilidad de quema</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1068"/>
        <source>Fix geometries of the generated propagation polygons (native:fixgeometries)</source>
        <translation>Reparar geometrías de los polígonos de propagación generados (native:fixgeometries)</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1076"/>
        <source>Repair method passed to fix geometries (0:Linework, 1:Structure didn&apos;t work on MacOS)</source>
        <translation>Método de reparación pasado a reparar geometrías (0:Linework, 1:Estructura no funcionó en MacOS)</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1155"/>
        <source>Burn Probability</source>
        <translation>Probabilidad de quema</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1189"/>
        <source>Propagation Scars</source>
        <translation>Polígonos de cicatrices de propagación</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1208"/>
        <source>Fire Scar</source>
        <translation>Cicatriz de fuego</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="1211"/>
        <source>Simulator Post Processing</source>
        <translation>Post procesamiento de simulación</translation>
    </message>
    <message>
	<location filename="../algorithm_postsimulation.py" line="1229"/>
	<source> - Input &lt;b&gt;Sample&lt;/b&gt; Fire Scar is any of the ForestGrid files; with it a pattern search for all Grids(any digit)/ForestGrid(any digit).csv will be performed.
	    - Output &lt;b&gt;Final&lt;/b&gt; Scar raster needs simulation ran with Final Fire Scar option, each band is a simulation
	    - Output &lt;b&gt;Burn Probability&lt;/b&gt; raster is the mean of all simulations, requires &gt;1 simulations
	    - Output &lt;b&gt;Propagation&lt;/b&gt; Scars Polygons accumulates fixed-geometry, polygonized, in-memory rasters (4 steps); attributing for each one its: simulation, period, perimeter and area. This is known to fail in some qgis-versions, OSes or low RAM hardware. Mitigations:
	    A. Change the default .gpkg format to .shp or test other
	    B. Use the advanced options to tweak or disable the fix geometries option
	    C. &lt;b&gt;Skip this output altogether by clicking the option button &apos;...&apos; and selecting Skip Output&lt;/b&gt;

	    &lt;i&gt;If the Bundle algorithm failed for you, this propagation output is the most likely cause...&lt;/i&gt;</source>
        <translation> - La cicatriz de fuego &lt;b&gt;Muestra&lt;/b&gt; es cualquiera de los archivos ForestGrid; con ella se realizará una búsqueda de patrones para todos los Grids(cualquier dígito)/ForestGrid(cualquier dígito).csv.
	    - La cicatriz de fuego &lt;b&gt;Final&lt;/b&gt; salida raster necesita simulaciones ejecutadas con la opción Cicatriz Final del Fuego, cada banda es una simulación
	    - La cicatriz de fuego &lt;b&gt;Probabilidad de Quema&lt;/b&gt; salida raster es la media de todas las simulaciones, requiere &gt;1 simulaciones
	    - La cicatriz de fuego &lt;b&gt;Propagación&lt;/b&gt; Polígonos de salida acumula rasters en memoria con geometría fija y poligonizados (4 pasos); atribuyendo a cada uno su: simulación, período, perímetro y área. Se sabe que falla en algunas versiones de qgis, sistemas operativos o hardware con poca RAM. Mitigaciones:
	    A. Cambiar el formato predeterminado .gpkg a .shp o probar otro
	    B. Usar las opciones avanzadas para ajustar o deshabilitar la opción de geometrías fijas
	    C. &lt;b&gt;Omitir esta salida por completo haciendo clic en el botón de opción '...' y seleccionando Omitir Salida&lt;/b&gt;

	    &lt;i&gt;Si el algoritmo Bundle falló para ti, esta salida de propagación es la causa más probable...&lt;/i&gt;</translation>
    </message>
</context>
<context>
    <name>StatisticSIMPP</name>
    <message>
        <location filename="../algorithm_postsimulation.py" line="763"/>
        <source>Base raster (normally fuel or elevation) to get the geotransform</source>
        <comment>BaseContext</comment>
        <translation>Raster base para posicionar el resultado (normalmente fuels o elevacion)</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="772"/>
        <source>Sample Spatial Statistic file (normally firesim_yymmdd_HHMMSS/results/Statistic/statistic.asc)
All ChosenName[0-9]*.asc files will be loaded
Known: </source>
        <translation>Archivo de muestra de estadística espacial (normalmente firesim_yymmdd_HHMMSS/results/Statistic/statistic.asc)
		Todos los archivos del patrón ChosenName[0-9]*.asc serán cargados</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="811"/>
        <source>Output raster</source>
        <comment>BaseContext</comment>
        <translation>Raster de salida</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="811"/>
        <source>mean &amp; std</source>
        <translation>media &amp; desv. estándar</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="956"/>
        <source>Simulator Post Processing</source>
        <translation>Post procesamiento de simulación</translation>
    </message>
    <message>
        <location filename="../algorithm_postsimulation.py" line="965"/>
        <source>Spatial Statistic</source>
        <translation>Estadística Espacial</translation>
    </message>
    <message>
	<location filename="../algorithm_postsimulation.py" line="974"/>
	<source>
	    This post processing algorithm, reads the raw output of C2F-W simulator and generates two rasters.
	    One has one band per simulation, named &quot;StatName&quot; (so N bands for N simulations), e.g., Surface Flame Lenght
	    
	    The second one has two bands corresponding to the mean and standard deviation, e.g., &quot;Mean&amp;StdDev Hit Rate Of Spread&quot;.
	    The &lt;b&gt;mean statistic&lt;/b&gt; sums, for each pixel, its values divided by &lt;b&gt;burnt count&lt;/b&gt;. 
	    The &lt;b&gt;standard deviation&lt;/b&gt; divides against &lt;b&gt;all simulations&lt;/b&gt;, not burnt count of each individual pixel.

	    Check the &lt;a href=https://fire2a.github.io/docs/qgis-toolbox/algo_simulator.html#options&gt;table below&lt;a/&gt; for more info
	    </source>
        <translation>
	    Este algoritmo de post procesamiento, lee la salida cruda del simulador C2F-W y genera dos rasters.
	    Uno tiene una banda por simulación, nombrada &quot;NombreEstadística&quot; (así N bandas para N simulaciones), por ejemplo, Longitud de Llama Superficial.

	    El segundo tiene dos bandas correspondientes a la media y la desviación estándar, por ejemplo, &quot;Media&amp;DesvEst Tasa de Impacto de Propagación&quot;.
	    La &lt;b&gt;estadística media&lt;/b&gt; suma, para cada píxel, sus valores divididos por el &lt;b&gt;conteo de quemados&lt;/b&gt;.
	    La &lt;b&gt;desviación estándar&lt;/b&gt; divide contra &lt;b&gt;todas las simulaciones&lt;/b&gt;, no el conteo de quemados de cada píxel individual.

	    Consulta la &lt;a href=https://fire2a.github.io/docs/qgis-toolbox/algo_simulator.html#options&gt;tabla a continuación&lt;a/&gt; para más información
	    </translation>
    </message>
</context>
<context>
    <name>Utils</name>
    <message>
        <location filename="../algorithm_utils.py" line="195"/>
        <source>This output is written to</source>
        <translation>Este resultado fue escrito en</translation>
    </message>
</context>
<context>
    <name>WeatherBuilder</name>
    <message>
        <location filename="../algorithm_scraps.py" line="137"/>
        <source>Two column csv file describing the number of times each scenario should be repeated</source>
        <translation>Archivo csv de dos columnas que describe el número de veces que cada escenario debe repetirse</translation>
    </message>
    <message>
        <location filename="../algorithm_scraps.py" line="151"/>
        <source>Weather Scenarios files</source>
        <translation>Archivos de escenarios meteorológicos</translation>
    </message>
    <message>
        <location filename="../algorithm_scraps.py" line="162"/>
        <source>Output directory</source>
        <comment>BaseContext</comment>
        <translation>Directorio de salida</translation>
    </message>
    <message>
        <location filename="../algorithm_scraps.py" line="162"/>
        <source>(destructive action warning: empties contents if already exists)</source>
        <translation>(advertencia de acción destructiva: vacía el contenido si ya existe)</translation>
    </message>
</context>
<context>
    <name>aConfig</name>
    <message>
        <location filename="../config.py" line="31"/>
        <source>Fuel</source>
        <translation>Combustible</translation>
    </message>
    <message>
        <location filename="../config.py" line="32"/>
        <source>Elevation</source>
        <translation>Elevación</translation>
    </message>
    <message>
        <location filename="../config.py" line="33"/>
        <source>Canopy Base Height</source>
        <translation>Altura de la primera rama</translation>
    </message>
    <message>
        <location filename="../config.py" line="34"/>
        <source>Canopy Bulk Density</source>
        <translation>Densidad de la cubierta</translation>
    </message>
    <message>
        <location filename="../config.py" line="35"/>
        <source>Canopy Cover Fraction</source>
        <translation>Fracción de cobertura</translation>
    </message>
    <message>
        <location filename="../config.py" line="36"/>
        <source>Canopy Height</source>
        <translation>Altura de la cubierta</translation>
    </message>
    <message>
        <location filename="../config.py" line="39"/>
        <source>Probability map</source>
        <translation>Mapa de probabilidad</translation>
    </message>
    <message>
        <location filename="../config.py" line="39"/>
        <source> (requires generation mode 1)</source>
        <translation> (requiere modo de generación 1)</translation>
    </message>
    <message>
        <location filename="../config.py" line="45"/>
        <source>Hit Rate Of Spread</source>
        <translation>Tasa de impacto de propagación (ROS)</translation>
    </message>
    <message>
        <location filename="../config.py" line="54"/>
        <source>Surface Flame Length</source>
        <translation>Longitud de llama superficial</translation>
    </message>
    <message>
        <location filename="../config.py" line="63"/>
        <source>Byram Surface Intensity</source>
        <translation>Intensidad superficial de Byram</translation>
    </message>
    <message>
        <location filename="../config.py" line="72"/>
        <source>Crown Fire Scar</source>
        <translation>Cicatriz de fuego de copa</translation>
    </message>
    <message>
        <location filename="../config.py" line="81"/>
        <source>Crown Fire Fuel Consumption Ratio</source>
        <translation>Ratio de consumo de combustible de fuego de copa</translation>
    </message>
    <message>
        <location filename="../config.py" line="90"/>
        <source>Surface Burn Fraction</source>
        <translation>Fracción de quema superficial</translation>
    </message>
    <message>
        <location filename="../config.py" line="91"/>
        <source> (only Canada FBP)</source>
        <translation> (solo Canadá FBP)</translation>
    </message>
    <message>
        <location filename="../config.py" line="100"/>
        <source>Crown Intensity</source>
        <translation>Intensidad de copa</translation>
    </message>
    <message>
        <location filename="../config.py" line="121"/>
        <source> (only Spain S&amp;B)</source>
        <translation> (solo España S&amp;B)</translation>
    </message>
    <message>
        <location filename="../config.py" line="110"/>
        <source>Crown Flame Length</source>
        <translation>Longitud de llama de copa</translation>
    </message>
    <message>
        <location filename="../config.py" line="120"/>
        <source>Max Flame Length</source>
        <translation>Longitud máxima de llama</translation>
    </message>
    <message>
        <location filename="../config.py" line="135"/>
        <source>Final Fire Scar</source>
        <translation>Cicatriz de fuego final</translation>
    </message>
    <message>
        <location filename="../config.py" line="143"/>
        <source>Propagation Fire Scars</source>
        <translation>Cicatrices de propagación del fuego</translation>
    </message>
    <message>
        <location filename="../config.py" line="151"/>
        <source>Propagation Directed Graph</source>
        <translation>Grafo dirigido de propagación</translation>
    </message>
    <message>
        <location filename="../config.py" line="159"/>
        <source>Ignition Points</source>
        <translation>Puntos de ignición</translation>
    </message>
    <message>
        <location filename="../config.py" line="170"/>
        <source>Burn Probability</source>
        <translation>Probabilidad de quema</translation>
    </message>
    <message>
        <location filename="../config.py" line="171"/>
        <source>Betweenness Centrality</source>
        <translation>Centralidad de intermediación</translation>
    </message>
    <message>
        <location filename="../config.py" line="172"/>
        <source>Downstream Protection Value</source>
        <translation>Valor de protección aguas abajo</translation>
    </message>
    <message>
        <location filename="../config.py" line="174"/>
        <source>Simulator Post Processing</source>
        <translation>Post procesamiento de simulación</translation>
    </message>
    <message>
        <location filename="../config.py" line="175"/>
        <source>Simulator Risk Metrics</source>
        <translation>Métricas de riesgo del simulador</translation>
    </message>
    <message>
        <location filename="../config.py" line="176"/>
        <source>Propagation Metrics</source>
        <translation> Métrica de propagación</translation>
    </message>
    <message>
        <location filename="../config.py" line="187"/>
        <source>0. Uniformly distributed random ignition point(s)</source>
        <translation>0. Punto(s) de ignición aleatorio(s) distribuidos uniformemente</translation>
    </message>
    <message>
        <location filename="../config.py" line="188"/>
        <source>1. Probability map distributed random ignition point(s)</source>
        <translation>1. Punto(s) de ignición aleatorio(s) distribuido(s) según un mapa de probabilidad</translation>
    </message>
    <message>
        <location filename="../config.py" line="189"/>
        <source>2. Single point on a (Vector)Layer</source>
        <translation>2. Punto único en una (Capa)Vectorial</translation>
    </message>
    <message>
        <location filename="../config.py" line="192"/>
        <source>0. Single weather file scenario</source>
        <translation>0. Escenario de archivo meteorológico único</translation>
    </message>
    <message>
        <location filename="../config.py" line="193"/>
        <source>1. Random draw from multiple weathers in a directory</source>
        <translation>1. Selección aleatoria de múltiples archivos meteorológicos en un directorio</translation>
    </message>
</context>
</TS>
